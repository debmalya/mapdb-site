<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Concurrency &mdash; MapDB</title>
    
    <link rel="stylesheet" href="../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="MapDB" href="../index.html" />
    <link rel="up" title="MapDB Manual" href="index.html" />
    <link rel="next" title="Appendix: Storage formats" href="format.html" />
    <link rel="prev" title="MapDB internals" href="internals.html" />
  
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

<!-- google analytics-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42074659-1', 'auto');
  ga('send', 'pageview');

</script>

  
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.post-list-style-disc {list-style-type: disc;}
    ul.post-list-style-none {list-style-type: none;}
    ul.post-list-style-circle {list-style-type: circle;}
  </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="getting-started.html">Intro</a></li>
    <li><a href="index.html">Docs</a></li>
    <li><a href="/blog.html">News</a></li>
    <li><a href="https://github.com/jankotek/mapdb">Github</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/logo.png" alt="MapDB" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="format.html" title="Appendix: Storage formats"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="internals.html" title="MapDB internals"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Concurrency</a><ul>
<li><a class="reference internal" href="#segment-locking">Segment locking</a></li>
<li><a class="reference internal" href="#collection-locking">Collection locking</a></li>
<li><a class="reference internal" href="#consistency-safety">Consistency safety</a></li>
<li><a class="reference internal" href="#executors">Executors</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="internals.html"
                        title="previous chapter">MapDB internals</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="format.html"
                        title="next chapter">Appendix: Storage formats</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/doc/concurrency.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="concurrency">
<h1>Concurrency<a class="headerlink" href="#concurrency" title="Permalink to this headline">¶</a></h1>
<p>All classes in MapDB are thread-safe and to some extend vertically scalable.
Reads should be linearly scalable without limitations.
Writes should scale linearly up to 4 CPU cores,  with a peak around 6 cores.
Greater write scalability is possible with a sharding or experimental memory allocator.</p>
<p>However MapDB design is relatively simple. There are global locks and stop-the-world states.
It is also flexible so it can be tuned well into most situations and
performance / safety compromises.</p>
<div class="section" id="segment-locking">
<h2>Segment locking<a class="headerlink" href="#segment-locking" title="Permalink to this headline">¶</a></h2>
<p>Here is a basic explanation of how MapDB can scale under concurrent access.
<a class="reference external" href="mailto:{&#37;&#52;&#48;javadoc">{<span>&#64;</span>javadoc</a> Engine} implements key-value storage. Instead of a single global lock,
it is split into multiple segments, each withs its own <code class="docutils literal"><span class="pre">ReadWriteLock</span></code></p>
<p>This way, the records can be updated concurrently to some extend.
Concurrent read operations are not blocked unless an update is running.</p>
<p>Under the segment locks is a global lock called &#8216;structural lock&#8217; which
protects the memory allocator. It is locked when record layout changes,
for example when space is allocated, a record was resized or free space is released.</p>
<div class="highlight-java"><div class="highlight"><pre><span class="c1">// read record from store</span>
<span class="n">locks</span><span class="o">[</span><span class="n">recid</span> <span class="o">%</span> <span class="n">locks</span><span class="o">.</span><span class="na">length</span><span class="o">].</span><span class="na">readLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//note readLock</span>
<span class="k">try</span><span class="o">{</span>
    <span class="c1">//look up recid, deserialize and return</span>
<span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
    <span class="n">locks</span><span class="o">[</span><span class="n">recid</span> <span class="o">%</span> <span class="n">locks</span><span class="o">.</span><span class="na">length</span><span class="o">].</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// update record from store</span>
<span class="n">locks</span><span class="o">[</span><span class="n">recid</span> <span class="o">%</span> <span class="n">locks</span><span class="o">.</span><span class="na">length</span><span class="o">].</span><span class="na">writeLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span>
<span class="k">try</span><span class="o">{</span>

    <span class="c1">//TODO finish update example</span>
<span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
    <span class="n">locks</span><span class="o">[</span><span class="n">recid</span> <span class="o">%</span> <span class="n">locks</span><span class="o">.</span><span class="na">length</span><span class="o">].</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The memory allocator uses single global lock, and that limits vertical scalability.
There are some workarounds.
For example, each segment can have its own storage file, so no shared state exists.</p>
</div>
<div class="section" id="collection-locking">
<h2>Collection locking<a class="headerlink" href="#collection-locking" title="Permalink to this headline">¶</a></h2>
<p>On top of <code class="docutils literal"><span class="pre">Engine</span></code> collections have their own locking layer. Each collection
adds its own locking to ensure that its data (tree nodes, pointers etc) are consistent.</p>
<p><code class="docutils literal"><span class="pre">BTreeMap</span></code> (aka TreeMap) is a lock free BTree implementation. It only locks a single node
on update and has excellent vertical scalability.</p>
<p><code class="docutils literal"><span class="pre">HTreeMap</span></code> splits its data into 16 segments based on key hash. The number of segments
is hardcoded into its design and can not be changed. However it has a simpler
design compared to <code class="docutils literal"><span class="pre">BTreeMap</span></code> and more predictable performance.
It is also easy to use separate storage for each segment in order to top boost its performance.</p>
<p>Please note that locking at collection layer might not use memory barrier. Since collections are
stateless (all state is in database), locks at this level only protects from concurrent modification.</p>
</div>
<div class="section" id="consistency-safety">
<h2>Consistency safety<a class="headerlink" href="#consistency-safety" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Map.put()</span></code> translates into multiple operations at <code class="docutils literal"><span class="pre">Engine</span></code> level.
For example a tree must be updated at more levels, counters incremented etc.
Under some configurations this might not be an atomic operation and could
cause data inconsistency.</p>
<p>For example two commits might happen while a tree is being updated.
The second commit is rolled back and the tree becomes inconsistent.
Or if an inconsistent snapshot is taken, while the tree is being updated,
that would cause an inconsistent backup, while the primary data could be fine.</p>
<p>There are two ways to solve this. First are the sequential safe collections
(usually lock-free), which can handle inconsistency at the expense of fragmentation and lower performance.
<code class="docutils literal"><span class="pre">BTreeMap</span></code> is sequentially safe, its nodes are updated in a way which handles inconsistency.</p>
<p>The second way is <em>Consistency Lock</em>. It is <code class="docutils literal"><span class="pre">ReadWriteLock</span></code> provided by <code class="docutils literal"><span class="pre">DB.getConsistencyLock()</span></code>.
Sequentially, unsafe operations (such as <code class="docutils literal"><span class="pre">HTreeMap.put()</span></code>) should be performed under read lock.
Operations which require a consistent state (taking snapshot, commit or close) should be performed under write lock.</p>
<p><code class="docutils literal"><span class="pre">DB</span></code> provides consistency lock:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span><span class="o">.</span><span class="na">memoryDB</span><span class="o">().</span><span class="na">make</span><span class="o">();</span>

<span class="c1">// there are two counters which needs to be incremented at the same time.</span>
<span class="n">Atomic</span><span class="o">.</span><span class="na">Long</span> <span class="n">a</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">atomicLong</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">);</span>
<span class="n">Atomic</span><span class="o">.</span><span class="na">Long</span> <span class="n">b</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">atomicLong</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">);</span>


<span class="c1">// update those two counters together</span>
<span class="n">db</span><span class="o">.</span><span class="na">consistencyLock</span><span class="o">().</span><span class="na">readLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//note readLock</span>
<span class="k">try</span><span class="o">{</span>
    <span class="n">a</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
    <span class="c1">// if snapshot or commit would happen here, two counters would be inconsistent</span>
    <span class="n">b</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
<span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
    <span class="n">db</span><span class="o">.</span><span class="na">consistencyLock</span><span class="o">().</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">//now backup two counters (simulates taking snapshot)</span>
<span class="n">db</span><span class="o">.</span><span class="na">consistencyLock</span><span class="o">().</span><span class="na">readLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span>  <span class="c1">//not writeLock</span>
<span class="k">try</span><span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
            <span class="n">a</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">);</span>
<span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
    <span class="n">db</span><span class="o">.</span><span class="na">consistencyLock</span><span class="o">().</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Please note that Consistency Lock might not use memory barrier. Since collections are
stateless (all state is in database), locks at this level only protects from concurrent modification.
For details consult MapDB source code.</p>
</div>
<div class="section" id="executors">
<h2>Executors<a class="headerlink" href="#executors" title="Permalink to this headline">¶</a></h2>
<p>Some tasks, such as write or queue maintenance, could be done in a background thread. In default
configuration MapDB does not start any threads (its safer), but piggy backs those tasks as part of regular operations.
This might slow down MapDB operations.</p>
<p>Another option is to give MapDB an executor which performs tasks on the background. In this case
some tasks will be executed asynchronously (writes) or in parallel (compaction). The simplest way is to enable the executor globally:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="c1">//enable executors globally</span>
        <span class="o">.</span><span class="na">executorEnable</span><span class="o">()</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>Concurrent execution usually improves the performance, but sometimes it might make it worse. For that, MapDB has several
options to enable Executor only for specific tasks. For example a parallel compaction has no benefit for in-memory store,
but on-disk it brings large improvement, since IO (and disk seeks) can be done in parallel:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>

        <span class="c1">//enable executor used for compaction</span>
        <span class="o">.</span><span class="na">storeExecutorEnable</span><span class="o">()</span>
        <span class="c1">//or use your own executor</span>
        <span class="o">.</span><span class="na">storeExecutorEnable</span><span class="o">(</span>
                <span class="n">Executors</span><span class="o">.</span><span class="na">newSingleThreadScheduledExecutor</span><span class="o">()</span>
        <span class="o">)</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
<span class="c1">//perform compaction</span>
<span class="n">db</span><span class="o">.</span><span class="na">compact</span><span class="o">();</span>
</pre></div>
</div>
<p>Another option is to enable executor just for asynchronous writes:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span><span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="c1">//TODO specific executor for async write</span>


        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>And finally, for cache expiration in reference based cache (hard, soft or weak cache):</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span><span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="c1">// enable executor just for instance cache</span>
        <span class="o">.</span><span class="na">cacheExecutorEnable</span><span class="o">()</span>
        <span class="c1">// or one can use its own executor</span>
        <span class="o">.</span><span class="na">cacheExecutorEnable</span><span class="o">(</span><span class="n">Executors</span><span class="o">.</span><span class="na">newSingleThreadScheduledExecutor</span><span class="o">())</span>

        <span class="c1">//only some caches are using executor for its expirations:</span>
        <span class="o">.</span><span class="na">cacheHardRefEnable</span><span class="o">()</span>    <span class="c1">//TODO check hardref cache uses executors</span>
        <span class="o">.</span><span class="na">cacheLRUEnable</span><span class="o">()</span>        <span class="c1">//TODO check LRU cache uses executors</span>
        <span class="o">.</span><span class="na">cacheWeakRefEnable</span><span class="o">()</span>
        <span class="o">.</span><span class="na">cacheSoftRefEnable</span><span class="o">()</span>

        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>There is also the question about how many threads and what type of Executor one should use. MapDB uses
<a class="reference external" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a>
to execute its tasks. Previous MapDB versions were starting threads directly, but that meant problems in restricted and managed environments
such as J2EE containers. It is possible to supply your own Executor directly, as usually you can use one of the factory methods in
<code class="docutils literal"><span class="pre">Executors</span></code>:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="c1">//this would just enable global executor with default value</span>
        <span class="c1">// .executorEnable()</span>
        <span class="c1">//this will enable global executor supplied by user</span>
        <span class="o">.</span><span class="na">executorEnable</span><span class="o">(</span>
                <span class="c1">//TODO Executors.newSingleThreadScheduledExecutor()</span>
        <span class="o">)</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>

<span class="c1">//remember that executor gets closed on shutdown</span>
<span class="n">db</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</pre></div>
</div>
<p>TODO how many threads and executor selection</p>
<p>The Executor keeps threads running on the background. That could mean memory leak and also prevents JVM from shutting down.
And if executor keeps running after db is closed,
background tasks would fail with an exception and possibly loose unwritten data.
For that reason  <code class="docutils literal"><span class="pre">DB.close()</span></code> shutdowns all Executors associated with DB instance,
before it is closed. This way all background task are finished (and synced) before DB is closed.</p>
<p>Currently it is not possible to reuse Executor after DB was closed. It is also not possible to share Executor between
DB instances if one of them is closed. The solution for that is to provide Executor wrapper, which only shutdowns its own tasks,
but that is not implemented yet.</p>
<p>TODO executor sharing wrapper</p>
</div>
</div>

  <div class="section">
  
  
  </div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="format.html" title="Appendix: Storage formats"
             >next</a> |</li>
        <li class="right" >
          <a href="internals.html" title="MapDB internals"
             >previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Jan Kotek.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>