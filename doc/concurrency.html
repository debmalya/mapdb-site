<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Concurrency &mdash; MapDB</title>
    
    <link rel="stylesheet" href="../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="MapDB" href="../index.html" />
    <link rel="up" title="MapDB documentation" href="index.html" />
    <link rel="next" title="Operations" href="operations.html" />
    <link rel="prev" title="Transactions" href="transactions.html" />
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

<!-- google analytics-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42074659-1', 'auto');
  ga('send', 'pageview');

</script>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="getting-started.html">Intro</a></li>
    <li><a href="index.html">Docs</a></li>
    <li><a href="https://github.com/jankotek/mapdb">Github</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/logo.png" alt="MapDB" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="operations.html" title="Operations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="transactions.html" title="Transactions"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">MapDB documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Concurrency</a><ul>
<li><a class="reference internal" href="#segment-locking">Segment locking</a></li>
<li><a class="reference internal" href="#collection-locking">Collection locking</a></li>
<li><a class="reference internal" href="#consistency-safety">Consistency safety</a></li>
<li><a class="reference internal" href="#executors">Executors</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="transactions.html"
                        title="previous chapter">Transactions</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="operations.html"
                        title="next chapter">Operations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/doc/concurrency.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="concurrency">
<h1>Concurrency<a class="headerlink" href="#concurrency" title="Permalink to this headline">¶</a></h1>
<p>All classes in MapDB are thread-safe and to some extend vertically scalable.
Reads should be linearly scalable without limitations.
Writes should scale to 4 CPU cores linearly with peak around 6 cores.
Greater write scalability is possible with sharding or experimental memory allocator.</p>
<p>However MapDB design is relatively simple. There are global locks and stop-word states.
It is also flexible so it can be tuned well into most situations and
performance / safety compromises.</p>
<div class="section" id="segment-locking">
<h2>Segment locking<a class="headerlink" href="#segment-locking" title="Permalink to this headline">¶</a></h2>
<p>Here is basic explanation how MapDB can scale under concurrent access.
<a class="reference external" href="mailto:{&#37;&#52;&#48;javadoc">{<span>&#64;</span>javadoc</a> Engine} implements key-value storage. Instead of single global lock
it is split into multiple segments, each withs its own <code class="docutils literal"><span class="pre">ReadWriteLock</span></code></p>
<p>This way records can be updated concurrently to some extend.
Concurrent read operations are not blocked unless update is running.</p>
<p>Inside segment locks is global lock called &#8216;structural lock&#8217; which
protects memory allocator. It is locked when record layout changes,
for example space is allocated, record was resided or free space released.</p>
<div class="highlight-java"><div class="highlight"><pre><span class="c1">// read record from store</span>
<span class="n">locks</span><span class="o">[</span><span class="n">recid</span> <span class="o">%</span> <span class="n">locks</span><span class="o">.</span><span class="na">length</span><span class="o">].</span><span class="na">readLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//note readLock</span>
<span class="k">try</span><span class="o">{</span>
    <span class="c1">//look up recid, deserialize and return</span>
<span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
    <span class="n">locks</span><span class="o">[</span><span class="n">recid</span> <span class="o">%</span> <span class="n">locks</span><span class="o">.</span><span class="na">length</span><span class="o">].</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// update record from store</span>
<span class="n">locks</span><span class="o">[</span><span class="n">recid</span> <span class="o">%</span> <span class="n">locks</span><span class="o">.</span><span class="na">length</span><span class="o">].</span><span class="na">writeLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span>
<span class="k">try</span><span class="o">{</span>

    <span class="c1">//TODO finish update example</span>
<span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
    <span class="n">locks</span><span class="o">[</span><span class="n">recid</span> <span class="o">%</span> <span class="n">locks</span><span class="o">.</span><span class="na">length</span><span class="o">].</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Memory allocator under global lock limits vertical scalability, so there
are various workarounds.
For example each segment can have its own storage file, so no shared state exists.</p>
</div>
<div class="section" id="collection-locking">
<h2>Collection locking<a class="headerlink" href="#collection-locking" title="Permalink to this headline">¶</a></h2>
<p>On top of <code class="docutils literal"><span class="pre">Engine</span></code> locking are implemented collections. Each collection
add its own locking to ensure that its data (tree nodes, pointers etc) are consistent.</p>
<p><code class="docutils literal"><span class="pre">BTreeMap</span></code> (aka TreeMap) is lock free BTree implementation. It only locks single node
on update and has excellent vertical scalability.</p>
<p><code class="docutils literal"><span class="pre">HTreeMap</span></code> splits its data into 16 segments based on key hash. Number of segments
is hardcoded into its design and can not be changed. However its has simpler
design compared to <code class="docutils literal"><span class="pre">BTreeMap</span></code> and more predictable performance.
It is also easy to use separate storage for each segment top boost its performance.</p>
</div>
<div class="section" id="consistency-safety">
<h2>Consistency safety<a class="headerlink" href="#consistency-safety" title="Permalink to this headline">¶</a></h2>
<p>Map.put() translates into multiple operations at <code class="docutils literal"><span class="pre">Engine</span></code> level.
Tree must be updated at more levels, counters incremented etc.
Under some configurations this might not be atomic operation and could
cause data inconsistency.</p>
<p>For example two commits might happen while tree is being updated,
second commit is rolled back and tree becomes inconsistent.
Or inconsistent snapshot is taken while tree is updated,
that would cause inconsistent backup, while primary data would be fine.</p>
<p>There are two ways to solve this. First are sequential safe collections
(usually lock-free) which can handle inconsistency at expense of fragmentation and lower performance.
<code class="docutils literal"><span class="pre">BTreeMap</span></code> is sequentially safe, its nodes are updated in way which handles inconsistency.</p>
<p>Second way is <em>Consistency Lock</em>. It is <code class="docutils literal"><span class="pre">ReadWriteLock</span></code> provided by <code class="docutils literal"><span class="pre">DB.getConsistencyLock()</span></code>.
Sequentially unsafe operations (such as <code class="docutils literal"><span class="pre">HTreeMap.put()</span></code>) should be performed under read lock.
Operations which require consistent state (taking snapshot, commit or close) should be performed under write lock.</p>
<p><code class="docutils literal"><span class="pre">DB</span></code> provides consistency lock:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span><span class="o">.</span><span class="na">memoryDB</span><span class="o">().</span><span class="na">make</span><span class="o">();</span>

<span class="c1">// there are two counters which needs to be incremented at the same time.</span>
<span class="n">Atomic</span><span class="o">.</span><span class="na">Long</span> <span class="n">a</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">atomicLong</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">);</span>
<span class="n">Atomic</span><span class="o">.</span><span class="na">Long</span> <span class="n">b</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">atomicLong</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">);</span>


<span class="c1">// update those two counters together</span>
<span class="n">db</span><span class="o">.</span><span class="na">consistencyLock</span><span class="o">().</span><span class="na">readLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//note readLock</span>
<span class="k">try</span><span class="o">{</span>
    <span class="n">a</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
    <span class="c1">// if snapshot or commit would happen here, two counters would be inconsistent</span>
    <span class="n">b</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
<span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
    <span class="n">db</span><span class="o">.</span><span class="na">consistencyLock</span><span class="o">().</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">//now backup two counters (simulates taking snapshot)</span>
<span class="n">db</span><span class="o">.</span><span class="na">consistencyLock</span><span class="o">().</span><span class="na">readLock</span><span class="o">().</span><span class="na">lock</span><span class="o">();</span>  <span class="c1">//not writeLock</span>
<span class="k">try</span><span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
            <span class="n">a</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">get</span><span class="o">()</span>
    <span class="o">);</span>
<span class="o">}</span><span class="k">finally</span> <span class="o">{</span>
    <span class="n">db</span><span class="o">.</span><span class="na">consistencyLock</span><span class="o">().</span><span class="na">readLock</span><span class="o">().</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="executors">
<h2>Executors<a class="headerlink" href="#executors" title="Permalink to this headline">¶</a></h2>
<p>Some tasks such as write or queue maintenance could be done in background thread. In default
configuration MapDB does not start any threads (its safer), but piggy backs those tasks to regular operations, at cost
of slowing them down.</p>
<p>Other option is to give MapDB an executor which could perform those tasks on background. In this case
some tasks will be executed asynchronously (writes) or in parallel (compaction). Simplest is to enable executor globally:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="c1">//enable executors globally</span>
        <span class="o">.</span><span class="na">executorEnable</span><span class="o">()</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>Concurrent execution usually improves performance, but sometimes it might make it worse. For that MapDB has several
options to enable Executor only for specific tasks. For example parallel in-memory compaction has no benefit,
but on-disk it has large improvement, since IO can be done in parallel:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>

        <span class="c1">//enable executor used for compaction</span>
        <span class="o">.</span><span class="na">storeExecutorEnable</span><span class="o">()</span>
        <span class="c1">//or use your own executor</span>
        <span class="o">.</span><span class="na">storeExecutorEnable</span><span class="o">(</span>
                <span class="n">Executors</span><span class="o">.</span><span class="na">newSingleThreadScheduledExecutor</span><span class="o">()</span>
        <span class="o">)</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
<span class="c1">//perform compaction</span>
<span class="n">db</span><span class="o">.</span><span class="na">compact</span><span class="o">();</span>
</pre></div>
</div>
<p>Other option is to enable executor just for asynchronous writes:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span><span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="c1">//TODO specific executor for async write</span>


        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>And finally for cache expiration in reference based cache (hard, soft or weak cache):</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span><span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="c1">// enable executor just for instance cache</span>
        <span class="o">.</span><span class="na">cacheExecutorEnable</span><span class="o">()</span>
        <span class="c1">// or one can use its own executor</span>
        <span class="o">.</span><span class="na">cacheExecutorEnable</span><span class="o">(</span><span class="n">Executors</span><span class="o">.</span><span class="na">newSingleThreadScheduledExecutor</span><span class="o">())</span>

        <span class="c1">//only some caches are using executor for its expirations:</span>
        <span class="o">.</span><span class="na">cacheHardRefEnable</span><span class="o">()</span>    <span class="c1">//TODO check hardref cache uses executors</span>
        <span class="o">.</span><span class="na">cacheLRUEnable</span><span class="o">()</span>        <span class="c1">//TODO check LRU cache uses executors</span>
        <span class="o">.</span><span class="na">cacheWeakRefEnable</span><span class="o">()</span>
        <span class="o">.</span><span class="na">cacheSoftRefEnable</span><span class="o">()</span>

        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>There is also question how many threads and what type of Executor one should use. MapDB uses
<a class="reference external" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a>
to execute its tasks. Previous MapDB versions were starting threads directly, but that meant problem in restricted and managed environments
such as J2EE containers. It is possible to supply your own Executor directly, usually you can use one of factory methods in
<code class="docutils literal"><span class="pre">Executors</span></code>:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="c1">//this would just enable global executor with default value</span>
        <span class="c1">// .executorEnable()</span>
        <span class="c1">//this will enable global executor supplied by user</span>
        <span class="o">.</span><span class="na">executorEnable</span><span class="o">(</span>
                <span class="c1">//TODO Executors.newSingleThreadScheduledExecutor()</span>
        <span class="o">)</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>

<span class="c1">//remember that executor gets closed on shutdown</span>
<span class="n">db</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</pre></div>
</div>
<p>TODO how many threads and executor selection</p>
<p>Executor keeps threads running on background. That means memory leak and could prevent JVM from shutting down.
Also background tasks would fail after DB has been closed. For that reason  <code class="docutils literal"><span class="pre">DB.close()</span></code> shutdowns
all Executors associated with DB instance, before it is closed. This way all background jobs are finished before
DB is closed.</p>
<p>So currently it is not possible to reuse Executor after DB was closed. It is also not possible to share Executor between
DB instances if one of them is closed. Solution for that is to provide Executor wrapper, which only shutdowns its own tasks,
but that is not implemented yet. TODO executor sharing</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="operations.html" title="Operations"
             >next</a> |</li>
        <li class="right" >
          <a href="transactions.html" title="Transactions"
             >previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >MapDB documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Jan Kotek.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>