<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Performance and durability &mdash; MapDB</title>
    
    <link rel="stylesheet" href="../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="MapDB" href="../index.html" />
    <link rel="up" title="MapDB Manual" href="index.html" />
    <link rel="next" title="Caches" href="caches.html" />
    <link rel="prev" title="DB and DBMaker" href="db-and-dbmaker.html" />
  
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

<!-- google analytics-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42074659-1', 'auto');
  ga('send', 'pageview');

</script>

  
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.post-list-style-disc {list-style-type: disc;}
    ul.post-list-style-none {list-style-type: none;}
    ul.post-list-style-circle {list-style-type: circle;}
  </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="getting-started.html">Intro</a></li>
    <li><a href="index.html">Docs</a></li>
    <li><a href="https://github.com/jankotek/mapdb">Github</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/logo.png" alt="MapDB" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="caches.html" title="Caches"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="db-and-dbmaker.html" title="DB and DBMaker"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Performance and durability</a><ul>
<li><a class="reference internal" href="#transactions-disabled">Transactions disabled</a></li>
<li><a class="reference internal" href="#memory-mapped-files-mmap">Memory mapped files (mmap)</a></li>
<li><a class="reference internal" href="#file-channel">File channel</a></li>
<li><a class="reference internal" href="#checksums">Checksums</a></li>
<li><a class="reference internal" href="#cache">Cache</a></li>
<li><a class="reference internal" href="#asynchronous-write">Asynchronous write</a></li>
<li><a class="reference internal" href="#in-memory-mode">In-memory mode</a></li>
<li><a class="reference internal" href="#allocation-options">Allocation options</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="db-and-dbmaker.html"
                        title="previous chapter">DB and DBMaker</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="caches.html"
                        title="next chapter">Caches</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/doc/performance.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="performance-and-durability">
<h1>Performance and durability<a class="headerlink" href="#performance-and-durability" title="Permalink to this headline">¶</a></h1>
<p>In default configuration MapDB uses very conservative, safe and slow settings.
Other options make it several times faster, but when used incorrectly,
they might  lead to memory leaks, data corruption or even JVM crash!
Make sure you understand implications and read Java Doc on <code class="docutils literal"><span class="pre">DBMaker</span></code>.</p>
<p>On other side maybe author is too paranoid,
his goal is to minimize number of questions on mailing list,
and very safe settings works best for that case.
Many options works just fine except some very exotic circumstances.</p>
<p>Good performance is usually result of compromise between consistency,
speed and durability. MapDB gives several options to make this compromise.
There are 4 different storage implementations, commit and disk sync strategies,
caches, compressions...</p>
<p>This chapter outlines performance and durability related options</p>
<div class="section" id="transactions-disabled">
<h2>Transactions disabled<a class="headerlink" href="#transactions-disabled" title="Permalink to this headline">¶</a></h2>
<p>If a process dies in the middle of write, storage files might become
inconsistent. For example the pointer was updated with a new location,
but new data were not written yet. For this MapBD storage is protected by
write-ahead-log (WAL). WAL is
reliable and simple, and is used by many databases, such as Posgresql or
MySQL.</p>
<p>However WAL is slow, data has to be copied and synced multiple times between files.
So there is option to bypass WAL and write data directly to store.
In this case MapDB writes data several times faster.</p>
<p>That is great for in-memory stores or caches where data can be reconstructed.
Other use is to disable WAL for fast initial import, and latter enable it for
production use.</p>
<p>WAL is disabled with  <code class="docutils literal"><span class="pre">DBMaker.transactionDisable()</span></code>:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="o">.</span><span class="na">transactionDisable</span><span class="o">()</span>
        <span class="o">.</span><span class="na">closeOnJvmShutdown</span><span class="o">()</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>With WAL disabled you loose crash protection.  In this case you <strong>must</strong> correctly
close the store, or you will loose all your data. MapDB detects
unclean shutdown and will refuse to open such corrupted storage.</p>
<p>There is a shutdown hook to close the database automatically before JVM exits,
however this does not protect your data if JVM crashes or is killed.
Use <code class="docutils literal"><span class="pre">DBMaker.closeOnJvmShutdown()</span></code> option to enable it.</p>
<p>With transactions disabled you loose rollback capability,
<code class="docutils literal"><span class="pre">db.rollback()</span></code> will throw an exception. <code class="docutils literal"><span class="pre">db.commit()</span></code> will have
nothing to commit (all data are already stored), so it does the next best
thing: Commit tries to flush all the write caches and synchronizes the storage
files. So if you call <code class="docutils literal"><span class="pre">db.commit()</span></code> and do not make any more writes,
your store should be safe (no data loss) in case of JVM crash.</p>
</div>
<div class="section" id="memory-mapped-files-mmap">
<h2>Memory mapped files (mmap)<a class="headerlink" href="#memory-mapped-files-mmap" title="Permalink to this headline">¶</a></h2>
<p>MapDB was designed from ground to take advantage of mmap files. However
mmap files are limited to 4GB by addressing limit on 32bit JVM. Mmap have a
lot of nasty effects on 32bit JVM (it might crash if addressing limit is exceeded),
so by default we use a slower and safer disk access mode called Random-Access-File (RAF).</p>
<p>Mmap files are much faster compared to RAF. The exact speed bonus depends on
the operating system and disk case management, but is typically between 10%
and 300%.</p>
<p>Memory mapped files are activated with <code class="docutils literal"><span class="pre">DBMaker.mmapFileEnable()</span></code>
setting.</p>
<p>One can also activate mmap files only if a 64bit platform is detected:
<code class="docutils literal"><span class="pre">DBMaker.mmapFileEnableIfSupported()</span></code>.</p>
<p>Mmap files are highly dependent on the operating system. For example, on
Windows you cannot delete a mmap file while it is locked by JVM. If
Windows JVM dies without closing the mmap file, you have to restart Windows
to release the file lock.</p>
<p>There is also <a class="reference external" href="http://bugs.java.com/view_bug.do?bug_id=4724038">bug in JVM</a>.
Mmaped file handles are not released until <code class="docutils literal"><span class="pre">DirectByteBuffer</span></code> is GCed.
That means that mmap file remains even after <code class="docutils literal"><span class="pre">db.close()</span></code> is called.
On Windows it prevents file to be reopened or deleted.
On Linux it consumes file descriptors, and could lead to errors once all descriptors are used.</p>
<p>There is a workaround for this bug using undocumented API.
But it was linked to JVM crashes in rare cases and is disabled by default.
Use <code class="docutils literal"><span class="pre">DBMaker.fileMmapCleanerHackEnable()</span></code> to enable it.</p>
<p>Here is example with all mmap related options:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
    <span class="o">.</span><span class="na">fileDB</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="o">.</span><span class="na">fileMmapEnable</span><span class="o">()</span>            <span class="c1">// always enable mmap</span>
    <span class="o">.</span><span class="na">fileMmapEnableIfSupported</span><span class="o">()</span> <span class="c1">// only enable on supported platforms</span>
    <span class="o">.</span><span class="na">fileMmapCleanerHackEnable</span><span class="o">()</span> <span class="c1">// closes file on DB.close()</span>
    <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
</div>
<div class="section" id="file-channel">
<h2>File channel<a class="headerlink" href="#file-channel" title="Permalink to this headline">¶</a></h2>
<p>By default MapDB uses <code class="docutils literal"><span class="pre">RandomAccessFile</span></code> to access disk storage. Outside fast mmap files there
is third option based on <code class="docutils literal"><span class="pre">FileChannel</span></code>. It should be faster than <code class="docutils literal"><span class="pre">RandomAccessFile</span></code>,
but has bit more overhead. It also works better under concurrent access (RAF has global lock).</p>
<p>FileChannel was causing problems in combination with <code class="docutils literal"><span class="pre">Thread.interrupt</span></code>. If threads
gets interrupted while doing IO, underlying channel is closed for all other threads.</p>
<p>To use FileChannel use <code class="docutils literal"><span class="pre">DBMaker.fileChannelEnable()</span></code> option:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
    <span class="o">.</span><span class="na">fileDB</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="o">.</span><span class="na">fileChannelEnable</span><span class="o">()</span>
    <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
</div>
<div class="section" id="checksums">
<h2>Checksums<a class="headerlink" href="#checksums" title="Permalink to this headline">¶</a></h2>
<p>You may want to protect your data in case file gets corrupted, and some bytes are
randomly replaced. MapDB has basic parity checks which detect such failure very early,
but it optionally supports CRC32 checksums. In this case, each record stores an extra 4 bytes
which contains its CRC32 checksum. If the data are somehow modified or
corrupted , the next read will fail with an exception.
This gives an early warning and prevents db from returning the wrong data.</p>
<p>CRC32 checksum has to be calculated on each put/modify/get operation so
this option has some performance overhead.
It affects the storage format, so once activated you always have to reopen the store
with this setting. Also checksum can not be latter activated, if the store
was created without CRC32.</p>
<p>Checksum is activated by this setting: <code class="docutils literal"><span class="pre">DBMaker.checksumEnable()</span></code>:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
    <span class="o">.</span><span class="na">fileDB</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="o">.</span><span class="na">checksumEnable</span><span class="o">()</span>
    <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
</div>
<div class="section" id="cache">
<h2>Cache<a class="headerlink" href="#cache" title="Permalink to this headline">¶</a></h2>
<p>By default MapDB has no cache enabled. It leaves operating system to do disk caching,
which works well enough on Linux with mmap files. With enough free heap memory,
there is option to cache frequently accessed object instances (instance cache). This decreases
disk IO and decreases deserialization overhead. On other side it could cause
Out of Memory errors, if cache is not flushed fast enough.</p>
<p>There is <a class="reference internal" href="caches.html"><em>entire chapter</em></a> on Caches, so here is just quick example to enable most
basic cache:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="o">.</span><span class="na">cacheHashTableEnable</span><span class="o">()</span>
        <span class="o">.</span><span class="na">cacheSize</span><span class="o">(</span><span class="mi">1000000</span><span class="o">)</span>     <span class="c1">//optionally change cache size</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
</div>
<div class="section" id="asynchronous-write">
<h2>Asynchronous write<a class="headerlink" href="#asynchronous-write" title="Permalink to this headline">¶</a></h2>
<p>Write operations such as <code class="docutils literal"><span class="pre">map.put(key,value)</span></code> blocks until data are written to underlying store.
There is option to place data into write queue, and write them latter in background thread.</p>
<p><code class="docutils literal"><span class="pre">.asyncWriteEnable()</span></code> options enables async write queue. You can also change its size with extra
parameter. Write queue can be flushed in background thread if enabled (with <code class="docutils literal"><span class="pre">executorEnable()</span></code>).
If there is no background executor write queue gets flushed as part of other operation (in that
case write operatiosn such as <code class="docutils literal"><span class="pre">map.put(key,value)</span></code> or <code class="docutils literal"><span class="pre">db.commit()</span></code> might block for very long time).</p>
<p>Async write options:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
    <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
    <span class="o">.</span><span class="na">asyncWriteEnable</span><span class="o">()</span>
    <span class="o">.</span><span class="na">asyncWriteQueueSize</span><span class="o">(</span><span class="mi">10000</span><span class="o">)</span> <span class="c1">//optionally change queue size</span>
    <span class="o">.</span><span class="na">executorEnable</span><span class="o">()</span>   <span class="c1">//enable background threads to flush data</span>
    <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>Asynchronous write does not compromise durability and consistency.
Operations such as <code class="docutils literal"><span class="pre">db.commit()</span></code> or <code class="docutils literal"><span class="pre">db.close()</span></code>
will block until write queue is flushed and synced to disk.</p>
</div>
<div class="section" id="in-memory-mode">
<h2>In-memory mode<a class="headerlink" href="#in-memory-mode" title="Permalink to this headline">¶</a></h2>
<p>MapDB has three in-memory stores:</p>
<p>On-heap which stores objects in <code class="docutils literal"><span class="pre">Map&lt;recid,Object&gt;</span></code> and does not use serialization.
This mode is very fast for small datasets, but is affected by GC, so performance drops from cliff
after a few gigabytes. It is activated with:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
    <span class="o">.</span><span class="na">heapDB</span><span class="o">()</span>
    <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>Store based on <code class="docutils literal"><span class="pre">byte[]</span></code>. In this mode data are serialized and stored into 1MB large byte[].
Technically this is still on-heap, but is not affected by GC overhead, since data are not visible to GC.
This mode is recommended by default, since it does not require any additional JVM settings.
Increasing maximal heap memory with <code class="docutils literal"><span class="pre">-Xmx10G</span></code> JVM parameter is enough.</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
    <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
    <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>Store based on <code class="docutils literal"><span class="pre">DirectByteBuffer</span></code>. In this case data are stored completely off-heap.
in 1MB DirectByteBuffers created with <code class="docutils literal"><span class="pre">ByteBuffer.allocateDirect(size)</span></code>.
You should increase maximal direct memory with JVM parameter.
This mode allows you to decrease maximal heap size to very small size (<code class="docutils literal"><span class="pre">-Xmx128M</span></code>).
Small heap size has usually better and more predictable performance.</p>
<div class="highlight-java"><div class="highlight"><pre><span class="c1">// run with: java -XX:MaxDirectMemorySize=10G</span>
<span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
    <span class="o">.</span><span class="na">memoryDirectDB</span><span class="o">()</span>
    <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
</div>
<div class="section" id="allocation-options">
<h2>Allocation options<a class="headerlink" href="#allocation-options" title="Permalink to this headline">¶</a></h2>
<p>By default MapDB tries minimize space usage and allocates space in 1MB increments.
This additional allocations might be slower than single large allocation.
There are two options to control storage initial size and size increment.
This example will allocate 10GB initially and then increment size in 512MB chunks:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span>
    <span class="o">.</span><span class="na">fileDB</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="o">.</span><span class="na">fileMmapEnable</span><span class="o">()</span>
    <span class="o">.</span><span class="na">allocateStartSize</span><span class="o">(</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">)</span>  <span class="c1">// 10GB</span>
    <span class="o">.</span><span class="na">allocateIncrement</span><span class="o">(</span><span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">)</span>       <span class="c1">// 512MB</span>
    <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>Allocation Increment has side effect on performance with mmap files.
MapDB maps file in series of DirectByteBuffer. Size of each buffer is equal to Size Increment
(1MB by default), so larger Size Increment means less buffers for the same disk store size.
Operations such as sync, flush and close have to traverse all buffers.
So larger Size Increment could speedup commit and close operations.</p>
</div>
</div>

  <div class="section">
  
  
  </div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="caches.html" title="Caches"
             >next</a> |</li>
        <li class="right" >
          <a href="db-and-dbmaker.html" title="DB and DBMaker"
             >previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Jan Kotek.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>