<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MapDB internals &mdash; MapDB</title>
    
    <link rel="stylesheet" href="../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="MapDB" href="../index.html" />
    <link rel="up" title="MapDB Manual" href="index.html" />
    <link rel="next" title="Concurrency" href="concurrency.html" />
    <link rel="prev" title="Transactions" href="transactions.html" />
  
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

<!-- google analytics-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42074659-1', 'auto');
  ga('send', 'pageview');

</script>

  
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.post-list-style-disc {list-style-type: disc;}
    ul.post-list-style-none {list-style-type: none;}
    ul.post-list-style-circle {list-style-type: circle;}
  </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="getting-started.html">Intro</a></li>
    <li><a href="index.html">Docs</a></li>
    <li><a href="/blog.html">Blog</a></li>
    <li><a href="https://github.com/jankotek/mapdb">Github</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/logo.png" alt="MapDB" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="concurrency.html" title="Concurrency"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="transactions.html" title="Transactions"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="document">
    <div class="documentwrapper">
        <div class="bodywrapper">
            <div class="body" role="main">
                
  <div class="section" id="mapdb-internals">
<h1>MapDB internals<a class="headerlink" href="#mapdb-internals" title="Permalink to this headline">¶</a></h1>
<p>This chapter gives a quick  introduction to MapDB internal
architecture. The rest of this manual assumes that you are familiar with this
chapter.</p>
<p>MapDB originally evolved as a store for astronomical desktop applications.
Over time it grew into a full database engine with concurrent access, durability etc.
But it evolved differently from most DBs, Pentium at 200MHz with 128 MB RAM does not give much space.
The major goal was tight integration with Java and to minimize overhead of any sort
(garbage collection, memory, CPU, stack trace length...).</p>
<p>What makes MapDB most different is that the serialization lifecycle is very different here.
In most DB engines the user has to serialize data himself and pass binary data into db. API
that looks similar to this:</p>
<div class="code java highlight-python"><div class="highlight"><pre>engine.update(long recid, byte[] data);
</pre></div>
</div>
<p>But MapDB serializes data itself by using a user supplied serializer:</p>
<div class="code java highlight-python"><div class="highlight"><pre>engine.update(long recid, Person data, Serializer&lt;Person&gt; serializer);
</pre></div>
</div>
<p>So serialization lifecycle is driven by MapDB rather than by the user. This
small detail is the reason why MapDB is so flexible. For example the <code class="docutils literal"><span class="pre">update</span></code>
method could pass the data-serializer pair to
<a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/AsyncWriteEngine.html">background-writer</a> thread
and return almost instantly. Or <code class="docutils literal"><span class="pre">Person</span></code> instance could be stored in
<a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/Caches.html">instance cache</a>, to minimise
deserilization overhead on multiple reads. <code class="docutils literal"><span class="pre">Person</span></code> does not even have
to be serialized, but could be stored in <code class="docutils literal"><span class="pre">Map&lt;Long,Person&gt;</span></code> map <a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/StoreHeap.html">on
heap</a>, in this case MapDB has speed
comparable to Java Collections.</p>
<p>Colons can be used to align columns.</p>
<div class="section" id="dictionary">
<h2>Dictionary<a class="headerlink" href="#dictionary" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Term</th>
<th class="head">Explanation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Record</td>
<td>Atomically stored value. Usually tree node or similar.
Transaction conflicts and locking is usually per record.</td>
</tr>
<tr class="row-odd"><td>Index Table</td>
<td>Table which translates recid into real offset and size in physical file.</td>
</tr>
<tr class="row-even"><td>Engine</td>
<td>Primitive key-value store used by collections for storage.</td>
</tr>
<tr class="row-odd"><td>Store</td>
<td>Engine implementation which actually persist data. Is wrapped by other Engines.</td>
</tr>
<tr class="row-even"><td>Volume</td>
<td>Abstraction over ByteBuffer or other raw data store. Used for files, memory, partition etc..</td>
</tr>
<tr class="row-odd"><td>Slice</td>
<td>Non overlapping pages used in Volume. Slice size is 1MB. Older name was &#8216;chunk&#8217;</td>
</tr>
<tr class="row-even"><td>Direct mode</td>
<td>With disabled transactions, data are written directly into file. It is fast,
but store is not protected from corruption during crashes.</td>
</tr>
<tr class="row-odd"><td>WAL</td>
<td>Write Ahead Log, way to protect store from corruption if db crashes during write.</td>
</tr>
<tr class="row-even"><td>RAF</td>
<td>Random Access File, way to access data on disk. Safer but slower method.</td>
</tr>
<tr class="row-odd"><td>MMap file</td>
<td>memory mapped file. On 32bit platform has size limit around 2GB. Faster than RAF.</td>
</tr>
<tr class="row-even"><td>index file</td>
<td>contains mapping between recid (index file offset) and record size and offset in
physical file (index value). Is organized as sequence of 8-byte longs</td>
</tr>
<tr class="row-odd"><td>index value</td>
<td>single 8-byte number from index file. Usually contains record offset in physical file.</td>
</tr>
<tr class="row-even"><td>recid</td>
<td>record identificator, a unique 8-byte long number which identifies record.
Recid is offset in index file. After record is deleted, its recid may be reused for
newly inserted record.</td>
</tr>
<tr class="row-odd"><td>record</td>
<td>atomical value stored in storage (Engine) identified by record identifier (recid).
In collections Record corresponds to tree nodes. In Maps record may not correspond to
Key-&gt;Value pair, as multiple keys may be stored inside single node.</td>
</tr>
<tr class="row-even"><td>physical file</td>
<td>Contains record binary data</td>
</tr>
<tr class="row-odd"><td>cache (or instance cache)</td>
<td>caches object instances (created with &#8216;new&#8217; keyword).
MapDB does not have traditional fixes-size-buffer cache for binary pages
(it relies on OS to do this). Instead deserialized objects are cached on heap to
minimise deserialization overhead.
Instance cache is main reason why your keys/values must be immutable.</td>
</tr>
<tr class="row-even"><td>BTreeMap</td>
<td>tree implementation behind TreeMap and TreeSet provided by MapDB</td>
</tr>
<tr class="row-odd"><td>HTreeMap</td>
<td>tree implementation behind HashMap and HashSet provided by MapDB</td>
</tr>
<tr class="row-even"><td>delta packing</td>
<td>compression method to minimalise space used by keys in BTreeMap. Keys are sorted,
so only difference between keys needs to be stored. You need to provide specialized
serializer to enable delta packing.</td>
</tr>
<tr class="row-odd"><td>append file db</td>
<td>alternative storage format. In this case no existing data are modified, but all changes
are appended to end of file. This may improve write speed and durability,
but introduces some tradeoffs.</td>
</tr>
<tr class="row-even"><td>temp map/set...</td>
<td>collection backed by file in temporary directory. Is usually configured to delete file
after close or on JVM exit. Data written into temp collection are not persisted between JVM restarts.</td>
</tr>
<tr class="row-odd"><td>async write</td>
<td>writes may be queued and written into file on background thread. This does not affect commit
durability (it blocks until queue is empty).</td>
</tr>
<tr class="row-even"><td>TX</td>
<td>equals to Concurrent Transaction.</td>
</tr>
<tr class="row-odd"><td>LongMap</td>
<td>specialized map which uses primitive long for keys. It minimises boxing overhead.</td>
</tr>
<tr class="row-even"><td>DB</td>
<td>API class exposed by MapDB. It is an abstraction over Engine which manages MapDB collections
and storage.</td>
</tr>
<tr class="row-odd"><td>DMaker</td>
<td>Builder style factory class, which opens and configures DB instances.</td>
</tr>
<tr class="row-even"><td>Collection Binding</td>
<td>MapDB mechanism to keep two collections synchronized. It provides secondary keys and values,
aggregations etc.. known from SQL and other databases. All functions are provided as static
methods in Bind class.</td>
</tr>
<tr class="row-odd"><td>Data Pump</td>
<td>Tool to import and manipulate large collections and storages.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dbmaker-and-db">
<h2>DBMaker and DB<a class="headerlink" href="#dbmaker-and-db" title="Permalink to this headline">¶</a></h2>
<p>90% of users will only need two classes from MapDB.
<a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/DBMaker.html">DBMaker</a> is a builder style
configurator which opens the database. <a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/DB.html">DB</a>
represents the store, it creates and opens collections, commits or rollbacks
data.</p>
<p>MapDB collections use <code class="docutils literal"><span class="pre">Engine</span></code> (simple key-value store) to persist its
data and state. Most of the functionality comes from mixing <code class="docutils literal"><span class="pre">Engine</span></code>
implementations and wrappers. For example, off-heap store with
asynchronous writes and instance cache could be instantiated by this
pseudo-code:</p>
<div class="code java highlight-python"><div class="highlight"><pre>//TODO this is obsolete, cache and async are integrated to Store

Engine engine = new Caches.HashTable(         //instance cache
                    new AsyncWriteEngine(     //asynchronous writes
                     new StoreWAL(            //actual store with WAL transactions
                      new Volume.MemoryVol()  //raw buffer used for storage
                )))
</pre></div>
</div>
<p>Reality is even more complex, since each wrapper takes extra parameters
and there are more levels. So <code class="docutils literal"><span class="pre">DBMaker</span></code> is a factory which takes
settings and wires all MapDB classes together.</p>
<p><code class="docutils literal"><span class="pre">DB</span></code> has a similar role. It is too hard to load and instantiate
collections manually (for example <code class="docutils literal"><span class="pre">HTreeMap</span></code> constructor takes 14
parameters). So <code class="docutils literal"><span class="pre">DB</span></code> stores all the settings in the Named Catalog and handles
collections. Named Catalog is a <code class="docutils literal"><span class="pre">Map&lt;String,Object&gt;</span></code> which is persisted
in store at fixed recid and contains parameters for all other named
collections and named records. In order to rename a collection one just has to
rename the relevant keys in the Named Catalog.</p>
</div>
<div class="section" id="layers">
<h2>Layers<a class="headerlink" href="#layers" title="Permalink to this headline">¶</a></h2>
<p>MapDB stack is a little bit different from most DBs. It integrates
instance cache and serialization usually found in ORM frameworks. On the
other hand MapDB eliminated fixed-size page and disk cache.</p>
<p>From raw-files to <code class="docutils literal"><span class="pre">Map</span></code> interface it has the following layers:</p>
<ol class="arabic simple">
<li><strong>Volume</strong> - an <code class="docutils literal"><span class="pre">ByteBuffer</span></code> like abstraction over raw store. There
are implementations for in-memory buffers or files.</li>
<li><strong>Store</strong> - primitive key-value store (implementation of <code class="docutils literal"><span class="pre">Engine</span></code>).
Key is offset on index table, value is variable length data. It has
single transaction. Implementations are Direct, WAL, append-only and
Heap (which does not use serialization). It performs serialization,
encryption and compression.</li>
<li><strong>AsyncWriterEngine</strong> - is optional <code class="docutils literal"><span class="pre">Store</span></code> (or <code class="docutils literal"><span class="pre">Engine</span></code>) wrapper
which performs all modifications on background thread.</li>
<li><strong>Instance Cache</strong> - is <code class="docutils literal"><span class="pre">Engine</span></code> wrapper which caches object
instances. This minimises deserilization overhead.</li>
<li><strong>TxMaker</strong> - is <code class="docutils literal"><span class="pre">Engine</span></code> factory which creates fake <code class="docutils literal"><span class="pre">Engine</span></code> for
each transaction or snapshot. Dirty data are stored on heap.</li>
<li><strong>Collections</strong> - such as TreeMap use <code class="docutils literal"><span class="pre">Engine</span></code> to store their data
and state.</li>
</ol>
</div>
<div class="section" id="volume">
<h2>Volume<a class="headerlink" href="#volume" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">ByteBuffer</span></code> is the best raw buffer abstraction Java has. However, its size
is limited by 31 bits addressing to 2GB. For that purpose MapDB uses
<code class="docutils literal"><span class="pre">Volume</span></code> as raw buffer abstraction. It takes multiple
<code class="docutils literal"><span class="pre">ByteBuffer</span></code>s and uses them together with 64bit addressing. Each
<code class="docutils literal"><span class="pre">ByteBuffer</span></code> has 1GB size and represents a <em>slice</em>. The IO operations which
cross slice boundaries are not supported (<code class="docutils literal"><span class="pre">readLong(1GB-3)</span></code> will throw
an exception at such offset). It is the responsibility of the higher layer <code class="docutils literal"><span class="pre">Store</span></code> to ensure
data do not overlap slice boundaries.</p>
<p>MapDB provides some Volume implementations: heap buffers, direct
(off-heap) buffers, memory mapped files and random access file. Each
implementation fits a different situation. For example memory mapped files
have great performance, however a 32bit desktop app will probably prefer
random access files. All implementations share the same format, so it is
possible to copy data (and entire store) between implementations.</p>
<p>Users can also supply their own <code class="docutils literal"><span class="pre">Volume</span></code> implementations. For example,
each 1Gb slice can be stored in a separate file on multiple disks, to
create software RAID. <code class="docutils literal"><span class="pre">Volume</span></code> could also handle duplication, binary
snapshots (MapDB snapshots are at different layer) or raw disks.</p>
</div>
<div class="section" id="store">
<h2>Store<a class="headerlink" href="#store" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/Engine.html">Engine</a> (and
<a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/Store.html">Store</a>) is a primitive key-value store
which maps recid (8-byte long record id) to some data (record). It has 4
methods for CRUD operations and 2 transaction methods:</p>
<div class="code java highlight-python"><div class="highlight"><pre>long put(A, Serializer&lt;A&gt;)
A get(long, Serializer&lt;A&gt;)
void update(long, A, Serializer&lt;A&gt;)
void delete(long, Serializer&lt;A&gt;)

void commit()
void rollback()
</pre></div>
</div>
<p>By default MapDB stack supports only a single transaction. However there
is the wrapper <code class="docutils literal"><span class="pre">TxMaker</span></code>, which stores un-commited data on heap and
provides concurrent ACID transactions.</p>
<p><a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/DB.html">DB</a> is a low level implementation of the
<code class="docutils literal"><span class="pre">Engine</span></code>, which stores data on raw <code class="docutils literal"><span class="pre">Volume</span></code>. It usually has two files
(or Volumes): index table and physical file. Recid (record ID) is
a usually fixed offset in the index table, which contains a pointer to the physical
file.</p>
<p>MapDB has multiple <code class="docutils literal"><span class="pre">Store</span></code> implementations, which differ in speed and
durability guarantees. User can also supply their own implementation.</p>
<p>First (and default) is <a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/StoreWAL.html">StoreWAL</a>.
In this case the Index Table contains the record size and offset in a physical
file. Large records are stored as a linked list. StoreWAL has free space
management, so released space is reused. However, over time it may
require compaction. StoreWAL stores modifications in <em>Write Ahead Log</em>,
which is a sequence of simple instructions, such as <em>write byte at this
offset</em>. On commit (or reopen) WAL is replayed into the main store, and
discarded after successful file sync. On rollback the WAL is discarded.</p>
<p><a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/StoreDirect.html">StoreDirect</a> shares the same
file format with <code class="docutils literal"><span class="pre">StoreWAL</span></code>, however it does not use write ahead log.
Instead, it writes data directly into files and performs file sync
on commit and close. This implementation trades any sort of data
protection for speed, so data are usually lost if <code class="docutils literal"><span class="pre">StoreDirect</span></code> is not
closed correctly (or synced after last write). Because there is no WAL,
this store does not support rollback. This store is used if transactions
are disabled.</p>
<p>The third implementation is <code class="docutils literal"><span class="pre">StoreAppend</span></code>, which provides append-only file
store. Because data are never overwritten, it is very solid and stable.
However space usage skyrockets, since it stores all modifications ever
made. TODO This store is not finished yet, so for example advanced
compaction is missing. TODO Also all possibilities of this store are not
explored (and documented yet). This store reads all data in sequence, in
order to build Index Table which points to newest version of each
record. The Index Table is stored on heap.</p>
</div>
<div class="section" id="txmaker">
<h2>TxMaker<a class="headerlink" href="#txmaker" title="Permalink to this headline">¶</a></h2>
<p>MapDB <code class="docutils literal"><span class="pre">Store</span></code> support only a single transaction. So concurrent
transactions need to be serialized and commited one by one. For this
there is <a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/TxMaker.html">TxMaker</a>. It is a factory
which creates a fake <code class="docutils literal"><span class="pre">Engine</span></code> for each transaction. Dirty (uncommited)
data are stored on heap. Optimistic concurrency control is used to
detect conflicts.
<a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/TxRollbackException.html">TxRollbackException</a> is
thrown on write or commit, if the current transaction was rolled back thanks
to an conflict.</p>
<p>TxMaker has a Serializable Isolation level and this level supports highest
guarantees. Other isolation levels are not implemented, since the author
does not want to support (and explain) isolation problems.</p>
<p>TODO Current TxMaker uses global lock, so concurrent performance sucks.
It will be rewritten after 1.0 release.</p>
</div>
<div class="section" id="collections">
<h2>Collections<a class="headerlink" href="#collections" title="Permalink to this headline">¶</a></h2>
<p>MapDB collection uses <code class="docutils literal"><span class="pre">Engine</span></code> as its parameter. There are two basic
indexes:</p>
<p><a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/BTreeMap.html">BTreeMap</a> is an ordered B-Linked-Tree.
It offers great concurrent performance. It is best for small sized keys.</p>
<p><a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/HTreeMap.html">HTreeMap</a> is a segmented Hash-Tree.
It is good for large keys and values. It also supports entry expiration
based on maximal size or time-to-live.</p>
<p>There also also <a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/Queues.html">Queues</a> and
<a class="reference external" href="http://www.mapdb.org/apidocs/org/mapdb/Atomic.html">Atomic</a> variables</p>
<p>TODO explain collections.</p>
</div>
<div class="section" id="serialization">
<h2>Serialization<a class="headerlink" href="#serialization" title="Permalink to this headline">¶</a></h2>
<p>MapDB contains its own serialization framework. TODO explain
serialization</p>
</div>
<div class="section" id="concurrency-patterns">
<h2>Concurrency patterns<a class="headerlink" href="#concurrency-patterns" title="Permalink to this headline">¶</a></h2>
<p>TODO concurrency patterns.</p>
</div>
</div>

  <div class="section">
  
  
  </div>


                <script>

if(window.location.href.indexOf('/blog/')>-1){

print('<br><br><br><hr><br><div id="disqus_thread"></div>');


/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = 'http://www.mapdb.org'; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'mapdb'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//mapdb.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();

}
</script>

            </div>
        </div>
    </div>

    <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="concurrency.html" title="Concurrency"
             >next</a> |</li>
        <li class="right" >
          <a href="transactions.html" title="Transactions"
             >previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Jan Kotek.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>