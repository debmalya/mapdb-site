<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>BTreeMap &mdash; MapDB</title>
    
    <link rel="stylesheet" href="../../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="MapDB" href="../../" />
    <link rel="up" title="MapDB Manual" href="../" />
    <link rel="next" title="Sorted Table Map" href="../sortedtablemap/" />
    <link rel="prev" title="HTreeMap" href="../htreemap/" />
  
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

<!-- google analytics-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42074659-1', 'auto');
  ga('send', 'pageview');

</script>

  
  <link rel="alternate" type="application/atom+xml"  href="../../blog/atom.xml" title="MapDB Blog">
  
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.postlist a {font-style: italic;}
    ul.postlist-style-disc {list-style-type: disc;}
    ul.postlist-style-none {list-style-type: none;}
    ul.postlist-style-circle {list-style-type: circle;}
  </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    <li><a href="../../">Home</a></li>
    <li><a href="../quick-start/">Quick start</a></li>
    <li><a href="../">Docs</a></li>
    <li><a href="../../blog/">Blog</a></li>
      <li><a href="../../support/">Support</a></li>

      <li><a href="https://github.com/jankotek/mapdb">Github</a></li>
  </ul>
  <div>
    <a href="../../">
      <img src="../../_static/logo.png" alt="MapDB" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../sortedtablemap/" title="Sorted Table Map"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="../htreemap/" title="HTreeMap"
             accesskey="P">previous</a> |</li>
        <li><a href="../../">Home</a>&nbsp;|</li>

          <li class="nav-item nav-item-1"><a href="../" accesskey="U">MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
<div class="sphinxsidebar" role="navigation" aria-label="main navigation">
    <div class="sphinxsidebarwrapper">
  <h3><a href="../../">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">BTreeMap</a><ul>
<li><a class="reference internal" href="#parameters">Parameters</a></li>
<li><a class="reference internal" href="#key-serializers">Key serializers</a></li>
<li><a class="reference internal" href="#data-pump">Data Pump</a></li>
<li><a class="reference internal" href="#fragmentation">Fragmentation</a></li>
<li><a class="reference internal" href="#prefix-submaps">Prefix submaps</a></li>
<li><a class="reference internal" href="#composite-keys-and-tuples">Composite keys and tuples</a></li>
<li><a class="reference internal" href="#multimap">Multimap</a></li>
<li><a class="reference internal" href="#compared-to-htreemap">Compared to HTreeMap</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search/" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><div class="sitemap">
    <h3>Site Map</h3>
    <ul>
        <li><a href="/support/">Support</a><ul>
            <li><a href="/support/#free-discovery-call">Free discovery call</a></li>
            <li><a href="/support/#consulting-services">Consulting services</a></li>
        </ul></li>
        <li><a href="/blog/">Blog</a></li>
        <li><a href="/success/">Who is using MapDB</a></li>
        <li><a href="/benchmarks/">Benchmarks</a></li>
        <li><a href="/changelog/">Changelog</a></li>
        <li><a href="/credits/">Credits</a></li>
        <li><a href="/careers/">Careers</a></li>

        <li><a href="/doc/">Documentation</a><ul>
            <li><a href="/doc/intro/">Intro</a></li>
            <li><a href="/doc/quick-start/">Quick start</a></li>
            <li><a href="/doc/db/">DB and DBMaker</a></li>
            <li><a href="/doc/htreemap/">HTreeMap</a></li>
            <li><a href="/doc/btreemap/">BTreeMap</a></li>
            <li><a href="/doc/sortedtablemap/">Sorted Table Map</a></li>
        </ul></li>
        <li><a href="/dokka/latest/mapdb/org.mapdb/">Javadoc</a></li>
    </ul>

    <h3>Links</h3>
    <ul>
        <li><a href="https://www.github.com/jankotek/mapdb/">Github</a>
        <li><a href="https://www.github.com/jankotek/mapdb/issues/">Issue tracker</a>
        <li><a href="https://groups.google.com/forum/#!forum/mapdb">Mail list</a></li>
        <li><a href="https://www.reddit.com/r/mapdb">Reddit forum</a></li>
        <li><a href="https://gitter.im/jankotek/mapdb">Gitter chat</a></li>
    </ul>
</div>
    </div>
</div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="btreemap">
<h1>BTreeMap<a class="headerlink" href="#btreemap" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal"><span class="pre">BTreeMap</span></code> provides <code class="docutils literal"><span class="pre">TreeMap</span></code> and <code class="docutils literal"><span class="pre">TreeSet</span></code> for MapDB. It is based on lock-free concurrent B-Linked-Tree.
It offers great performance for small keys and has good vertical scalability.</p>
<p>TODO explain compressions</p>
<p>TODO describe B-Linked-Tree</p>
<div class="section" id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h2>
<p>BTreeMap has optional parameters which can be specified by using maker.:</p>
<p>The most important among them are <strong>serializers</strong>. General serialization has
some guessing and overhead, so better performance is always achieved if
more specific serializers are  used. To specify the key and value serializer, use the code
bellow. There are dozens ready to use serializers available as static
fields on <code class="docutils literal"><span class="pre">Serializer</span></code> interface:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">treeMap</span><span class="p">(</span><span class="s">&quot;map&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">keySerializer</span><span class="p">(</span><span class="n">Serializer</span><span class="p">.</span><span class="n">LONG</span><span class="p">)</span>
        <span class="p">.</span><span class="n">valueSerializer</span><span class="p">(</span><span class="n">Serializer</span><span class="p">.</span><span class="n">STRING</span><span class="p">)</span>
        <span class="p">.</span><span class="n">createOrOpen</span><span class="p">();</span>
</pre></div>
</div>
<p>Another useful parameter is <strong>size counter</strong>. By default, a BTreeMap does not keep
track of its size and calling <code class="docutils literal"><span class="pre">map.size()</span></code> requires linear scan to count
all entries. If you enable size counter, in that case
<code class="docutils literal"><span class="pre">map.size()</span></code> is instant, but there is some overhead on inserts.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span>
        <span class="p">.</span><span class="n">treeMap</span><span class="p">(</span><span class="s">&quot;map&quot;</span><span class="p">,</span> <span class="n">Serializer</span><span class="p">.</span><span class="n">LONG</span><span class="p">,</span> <span class="n">Serializer</span><span class="p">.</span><span class="n">STRING</span><span class="p">)</span>
        <span class="p">.</span><span class="n">counterEnable</span><span class="p">()</span>
        <span class="p">.</span><span class="n">createOrOpen</span><span class="p">();</span>
</pre></div>
</div>
<p>BTrees store all their keys and values as part of a btree node. The node size affects performance a lot.
A large node means that many keys have to be deserialized on lookup.
A smaller node loads faster, but makes large BTrees deeper and requires more operations.
The default maximal node size is 32 entries and it can be changed in this way:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span>
        <span class="p">.</span><span class="n">treeMap</span><span class="p">(</span><span class="s">&quot;map&quot;</span><span class="p">,</span> <span class="n">Serializer</span><span class="p">.</span><span class="n">LONG</span><span class="p">,</span> <span class="n">Serializer</span><span class="p">.</span><span class="n">STRING</span><span class="p">)</span>
        <span class="p">.</span><span class="n">maxNodeSize</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
        <span class="p">.</span><span class="n">createOrOpen</span><span class="p">();</span>
</pre></div>
</div>
<p>Values are also stored as part of BTree leaf nodes. Large values means huge overhead and
on single <code class="docutils literal"><span class="pre">map.get(&quot;key&quot;)</span></code> 32 values are deserialized, but only a single value returned. In this
case, it is better to store the values outside the leaf node, in a separate record. In this case leaf node
only has a 6 byte recid pointing to the value.</p>
<p>Large values can also possible be compressed to save space. This example stores places
node outside BTree leaf nodes and applies compression on each value:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">treeMap</span><span class="p">(</span><span class="s">&quot;map&quot;</span><span class="p">)</span>
        <span class="c1">//TODO external values are not supported yet</span>
        <span class="c1">//.valuesOutsideNodesEnable()</span>
        <span class="p">.</span><span class="n">valueSerializer</span><span class="p">(</span><span class="k">new</span> <span class="n">SerializerCompressionWrapper</span><span class="p">(</span><span class="n">Serializer</span><span class="p">.</span><span class="n">STRING</span><span class="p">))</span>
        <span class="p">.</span><span class="n">createOrOpen</span><span class="p">();</span>
</pre></div>
</div>
<p>BTreeMap needs to sort its key somehow. By default it relies on <code class="docutils literal"><span class="pre">Comparable</span></code> interface implemented by most Java classes.
In case this interface is not implemented, a key serializer must be provided. One can for example compare Object arrays:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">Object</span><span class="p">[],</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">treeMap</span><span class="p">(</span><span class="s">&quot;map&quot;</span><span class="p">)</span>
        <span class="c1">// use array serializer for unknown objects</span>
        <span class="c1">// TODO db.getDefaultSerializer()</span>
        <span class="p">.</span><span class="n">keySerializer</span><span class="p">(</span><span class="k">new</span> <span class="n">SerializerArray</span><span class="p">(</span><span class="n">Serializer</span><span class="p">.</span><span class="n">JAVA</span><span class="p">))</span>
        <span class="c1">// or use serializer for specific objects such as String</span>
        <span class="p">.</span><span class="n">keySerializer</span><span class="p">(</span><span class="k">new</span> <span class="n">SerializerArray</span><span class="p">(</span><span class="n">Serializer</span><span class="p">.</span><span class="n">STRING</span><span class="p">))</span>
        <span class="p">.</span><span class="n">createOrOpen</span><span class="p">();</span>
</pre></div>
</div>
<p>Also primitive arrays can be used as keys. One can replace <code class="docutils literal"><span class="pre">String</span></code> by <code class="docutils literal"><span class="pre">byte[]</span></code>,which directly leads to better
performance:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">byte</span><span class="p">[],</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">treeMap</span><span class="p">(</span><span class="s">&quot;map&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">keySerializer</span><span class="p">(</span><span class="n">Serializer</span><span class="p">.</span><span class="n">BYTE_ARRAY</span><span class="p">)</span>
        <span class="p">.</span><span class="n">valueSerializer</span><span class="p">(</span><span class="n">Serializer</span><span class="p">.</span><span class="n">LONG</span><span class="p">)</span>
        <span class="p">.</span><span class="n">createOrOpen</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="key-serializers">
<h2>Key serializers<a class="headerlink" href="#key-serializers" title="Permalink to this headline">¶</a></h2>
<p>BTreeMap owns its performance to the way it handles keys. Lets illustrate this on an example with <code class="docutils literal"><span class="pre">Long</span></code> keys.</p>
<p>A long key occupies 8 bytes after serialization. To minimize space usage one could pack this value to make it smaller.
So the number 10 will occupy a single byte, 300 will take 2 bytes, 10000 three bytes etc. To make keys even more
packable, we need to store them in even smaller values. The keys are sorted, so lets use delta compression.
This will store the first value in full form and then only the differences between consecutive numbers.</p>
<p>Another improvement is to make the deserialization faster. In normal <code class="docutils literal"><span class="pre">TreeMap</span></code> keys are stored in wrapped form, such as
<code class="docutils literal"><span class="pre">Long[]</span></code>. That has a huge overhead, as each key requires new pointer, class header... BTreeMap will store keys in primitive
array <code class="docutils literal"><span class="pre">long[]</span></code>. And finally if keys are small enough it can even fit into <code class="docutils literal"><span class="pre">int[]</span></code>.
And because an array has better memory locality, there is a huge performance increase on binary searches.</p>
<p>It is simple to do such optimisation for numbers. But BTreeMap also applies that on other keys, such as <code class="docutils literal"><span class="pre">String</span></code>
(common prefix compression,single <code class="docutils literal"><span class="pre">byte[]</span></code> with offsets), <code class="docutils literal"><span class="pre">byte[]</span></code>, <code class="docutils literal"><span class="pre">UUID</span></code>, <code class="docutils literal"><span class="pre">Date</span></code> etc.</p>
<p>This sort of optimization is used automatically. All you have to do is provide the specialized key serializer:
<code class="docutils literal"><span class="pre">.keySerializer(Serializer.LONG)</span></code>.</p>
<p>There are several options and implementations to pack keys. Have a look at static fields with <code class="docutils literal"><span class="pre">_PACK</span></code> suffix in
<a class="reference external" href="http://www.mapdb.org/dokka/latest/mapdb/org.mapdb/-serializer/index.html">Serializer</a> class for more details.</p>
<p>TODO this is major feature, document details and add benchmarks</p>
</div>
<div class="section" id="data-pump">
<h2>Data Pump<a class="headerlink" href="#data-pump" title="Permalink to this headline">¶</a></h2>
<p>TODO data pump</p>
</div>
<div class="section" id="fragmentation">
<h2>Fragmentation<a class="headerlink" href="#fragmentation" title="Permalink to this headline">¶</a></h2>
<p>A trade-off for lock-free design is fragmentation after deletion. The B-Linked-Tree does not delete btree nodes after
entry removal, once they become empty. If you fill a BTreeMap and then remove all entries, about 40% of space will not
be released. Any value updates (keys are kept) are not affected by this fragmentation.</p>
<p>This fragmentation is different from storage fragmentation, so <code class="docutils literal"><span class="pre">DB.compact()</span></code> will not help.
A solution is to move all content into a new <code class="docutils literal"><span class="pre">BTreeMap</span></code>. As it is very fast with Data Pump streaming,
new Map will have zero fragmentation and better node locality (in theory disk cache friendly).</p>
<p>TODO provide utils to move BTreeMap content
TODO provide statistics to calculate BTreeMap fragmentation</p>
<p>In the future, we will provide BTreeMap wrapper, which will do this compaction automatically. It will use three collections:
the first <code class="docutils literal"><span class="pre">BTreeMap</span></code> will be read-only and will also contain the data. The econd small map will contain updates. Periodically a third map
will be produced as a merge of first two, and will be swapped with the primary.
<code class="docutils literal"><span class="pre">SSTable</span></code>&#8216;s in Cassandra and other databases works in a similar way.</p>
<p>TODO provide wrapper to compact/merge BTreeMap content automatically.</p>
</div>
<div class="section" id="prefix-submaps">
<h2>Prefix submaps<a class="headerlink" href="#prefix-submaps" title="Permalink to this headline">¶</a></h2>
<p>For array based keys (tuples, Strings, or arrays) MapDB provide prefix submap. It uses
intervals, so prefix submap is lazy, it does not load all keys. Here as example which uses
prefix on <code class="docutils literal"><span class="pre">byte[]</span></code> keys:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">byte</span><span class="p">[],</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span>
        <span class="p">.</span><span class="n">treeMap</span><span class="p">(</span><span class="s">&quot;towns&quot;</span><span class="p">,</span> <span class="n">Serializer</span><span class="p">.</span><span class="n">BYTE_ARRAY</span><span class="p">,</span> <span class="n">Serializer</span><span class="p">.</span><span class="n">INTEGER</span><span class="p">)</span>
        <span class="p">.</span><span class="n">createOrOpen</span><span class="p">();</span>

<span class="n">map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">&quot;New York&quot;</span><span class="p">.</span><span class="n">getBytes</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">&quot;New Jersey&quot;</span><span class="p">.</span><span class="n">getBytes</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">&quot;Boston&quot;</span><span class="p">.</span><span class="n">getBytes</span><span class="p">(),</span> <span class="mi">3</span><span class="p">);</span>

<span class="c1">//get all New* cities</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">byte</span><span class="p">[],</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">newCities</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">prefixSubMap</span><span class="p">(</span><span class="s">&quot;New&quot;</span><span class="p">.</span><span class="n">getBytes</span><span class="p">());</span>
</pre></div>
</div>
<p>TODO  key serializer must provide <code class="docutils literal"><span class="pre">nextValue</span></code> for prefix submaps. Implement it on more serializers</p>
</div>
<div class="section" id="composite-keys-and-tuples">
<h2>Composite keys and tuples<a class="headerlink" href="#composite-keys-and-tuples" title="Permalink to this headline">¶</a></h2>
<p>MapDB allows composite keys in form of <code class="docutils literal"><span class="pre">Object[]</span></code>.
Interval submaps can be used to fetch tuple subcomponents, or to create simple form of multimap.
Object array is not comparable, so you need to use specialized serializer which provides comparator.</p>
<p>Here is an example which creates <code class="docutils literal"><span class="pre">Map&lt;Tuple3&lt;String,</span> <span class="pre">String,</span> <span class="pre">Integer&gt;,</span> <span class="pre">Double&gt;</span></code> in form of Object[].
First component is town, second is street and third component is house number.
It has more parts, source code is on <a class="reference external" href="https://github.com/jankotek/mapdb-site/blob/master/src/test/java/doc/btreemap_composite_keys.java">github</a>
<code class="docutils literal"><span class="pre">SerializerArrayTuple</span></code> which takes serializers for each tuple component as constructor parameter:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// initialize db and map</span>
<span class="n">DB</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DBMaker</span><span class="p">.</span><span class="n">memoryDB</span><span class="p">().</span><span class="n">make</span><span class="p">();</span>
<span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">Object</span><span class="p">[],</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">treeMap</span><span class="p">(</span><span class="s">&quot;towns&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">keySerializer</span><span class="p">(</span><span class="k">new</span> <span class="n">SerializerArrayTuple</span><span class="p">(</span>
                <span class="n">Serializer</span><span class="p">.</span><span class="n">STRING</span><span class="p">,</span> <span class="n">Serializer</span><span class="p">.</span><span class="n">STRING</span><span class="p">,</span> <span class="n">Serializer</span><span class="p">.</span><span class="n">INTEGER</span><span class="p">))</span>
        <span class="p">.</span><span class="n">valueSerializer</span><span class="p">(</span><span class="n">Serializer</span><span class="p">.</span><span class="n">INTEGER</span><span class="p">)</span>
        <span class="p">.</span><span class="n">createOrOpen</span><span class="p">();</span>
</pre></div>
</div>
<p>Once map is populated we can get all houses in town of Cong by using prefix submap (town is first component in tuple):</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">//get all houses in Cong (town is primary component in tuple)</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">Object</span><span class="p">[],</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cong</span> <span class="o">=</span>
        <span class="n">map</span><span class="p">.</span><span class="n">prefixSubMap</span><span class="p">(</span><span class="k">new</span> <span class="n">Object</span><span class="p">[]{</span><span class="s">&quot;Cong&quot;</span><span class="p">});</span>
</pre></div>
</div>
<p>Prefix submap is equal to range query which uses submap method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cong</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">subMap</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">Object</span><span class="p">[]{</span><span class="s">&quot;Cong&quot;</span><span class="p">},</span>           <span class="c1">//shorter array is &#39;negative infinity&#39;</span>
        <span class="k">new</span> <span class="n">Object</span><span class="p">[]{</span><span class="s">&quot;Cong&quot;</span><span class="p">,</span><span class="n">null</span><span class="p">,</span><span class="n">null</span><span class="p">}</span> <span class="c1">// null is positive infinity&#39;</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Interval submap can only filter components on left side. To get components in middle we have combine submap with a forloop:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">String</span> <span class="nl">town</span><span class="p">:</span><span class="n">towns</span><span class="p">){</span> <span class="c1">//first loop iterates over towns</span>
    <span class="k">for</span><span class="p">(</span><span class="n">Integer</span> <span class="nl">salary</span><span class="p">:</span> <span class="c1">//second loop iterates over all houses on main street</span>
            <span class="n">map</span><span class="p">.</span><span class="n">prefixSubMap</span><span class="p">(</span><span class="k">new</span> <span class="n">Object</span><span class="p">[]{</span><span class="n">town</span><span class="p">,</span> <span class="s">&quot;Main Street&quot;</span><span class="p">}).</span><span class="n">values</span><span class="p">()){</span>
        <span class="n">total</span><span class="o">+=</span><span class="n">salary</span><span class="p">;</span> <span class="c1">//and calculate sum</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Salary sum for all Main Streets is: &quot;</span><span class="o">+</span><span class="n">total</span><span class="p">);</span>
</pre></div>
</div>
<p>Submaps are modifiable, we could delete all houses in town by calling <cite>clear()</cite> on submap etc..</p>
</div>
<div class="section" id="multimap">
<h2>Multimap<a class="headerlink" href="#multimap" title="Permalink to this headline">¶</a></h2>
<p>Multimap is a Map which associated multiple values with single key.
An example can be found in <a class="reference external" href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html">Guava</a>
or in <a class="reference external" href="https://www.eclipse.org/collections/javadoc/7.0.0/org/eclipse/collections/api/multimap/Multimap.html">Eclipse Collections</a>
It can be written as <cite>Map&lt;Key,List&lt;Value&gt;&gt;</cite>, but that does not work well in MapDB, we need keys and values to be immutable,
and List is not immutable.</p>
<p>There is a plan to implement Multimap from Guava and EC directly in MapDB. But until than there is an option to use
SortedSet in combination with tuples and interval subsets. Here is an example which constructs Set, inserts some data
and gets all values (second tuple component) associated with key (first tuple component):</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// initialize multimap: Map&lt;String,List&lt;Integer&gt;&gt;</span>
<span class="n">NavigableSet</span><span class="o">&lt;</span><span class="n">Object</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">multimap</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">treeSet</span><span class="p">(</span><span class="s">&quot;towns&quot;</span><span class="p">)</span>
        <span class="c1">//set tuple serializer</span>
        <span class="p">.</span><span class="n">serializer</span><span class="p">(</span><span class="k">new</span> <span class="n">SerializerArrayTuple</span><span class="p">(</span><span class="n">Serializer</span><span class="p">.</span><span class="n">STRING</span><span class="p">,</span> <span class="n">Serializer</span><span class="p">.</span><span class="n">INTEGER</span><span class="p">))</span>
        <span class="p">.</span><span class="n">createOrOpen</span><span class="p">();</span>

<span class="c1">// populate, key is first component in tuple (array), value is second</span>
<span class="n">multimap</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span> <span class="n">Object</span><span class="p">[]{</span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
<span class="n">multimap</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span> <span class="n">Object</span><span class="p">[]{</span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">});</span>
<span class="n">multimap</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span> <span class="n">Object</span><span class="p">[]{</span><span class="s">&quot;Anna&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>

<span class="c1">// print all values associated with John:</span>
<span class="n">Set</span> <span class="n">johnSubset</span> <span class="o">=</span> <span class="n">multimap</span><span class="p">.</span><span class="n">subSet</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">Object</span><span class="p">[]{</span><span class="s">&quot;John&quot;</span><span class="p">},</span>         <span class="c1">// lower interval bound</span>
        <span class="k">new</span> <span class="n">Object</span><span class="p">[]{</span><span class="s">&quot;John&quot;</span><span class="p">,</span> <span class="n">null</span><span class="p">});</span>  <span class="c1">// upper interval bound, null is positive infinity</span>
</pre></div>
</div>
<p>TODO delta packing for Tuples</p>
<p>TODO MapDB will soon implement multimap from Guava</p>
</div>
<div class="section" id="compared-to-htreemap">
<h2>Compared to HTreeMap<a class="headerlink" href="#compared-to-htreemap" title="Permalink to this headline">¶</a></h2>
<p>BTreeMap is better for smaller keys, such as numbers and short strings.</p>
<p>TODO compare to HTreeMap</p>
</div>
</div>

  <div class="section">
  
  
  </div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../sortedtablemap/" title="Sorted Table Map"
             >next</a></li>
        <li class="right" >
          <a href="../htreemap/" title="HTreeMap"
             >previous</a> |</li>
        <li><a href="../../">Home</a>&nbsp;|</li>

          <li class="nav-item nav-item-1"><a href="../" >MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, jan.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>