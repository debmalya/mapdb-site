<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>HTreeMap &mdash; MapDB</title>
    
    <link rel="stylesheet" href="../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="MapDB" href="../index.html" />
    <link rel="up" title="MapDB Manual" href="index.html" />
    <link rel="next" title="Secondary Collections" href="secondary-collections.html" />
    <link rel="prev" title="BTreeMap" href="btreemap.html" />
  
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

<!-- google analytics-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42074659-1', 'auto');
  ga('send', 'pageview');

</script>

  
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.post-list-style-disc {list-style-type: disc;}
    ul.post-list-style-none {list-style-type: none;}
    ul.post-list-style-circle {list-style-type: circle;}
  </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="getting-started.html">Intro</a></li>
    <li><a href="index.html">Docs</a></li>
    <li><a href="/blog.html">Blog</a></li>
    <li><a href="https://github.com/jankotek/mapdb">Github</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/logo.png" alt="MapDB" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="secondary-collections.html" title="Secondary Collections"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="btreemap.html" title="BTreeMap"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="document">
    <div class="documentwrapper">
        <div class="bodywrapper">
            <div class="body" role="main">
                
  <div class="section" id="htreemap">
<h1>HTreeMap<a class="headerlink" href="#htreemap" title="Permalink to this headline">¶</a></h1>
<p>HTreeMap provides <code class="docutils literal"><span class="pre">HashMap</span></code> and <code class="docutils literal"><span class="pre">HashSet</span></code>.
It has a great performance with large keys.
It also offers entry expiration based on the size or time-to-live</p>
<p>HTreeMap is a <em>segmented Hash Tree</em>. Most hash collections use hash table based in fixed size array and
when it becomes full, all data has to be moved and rehashed into
a new, bigger table. HTreeMap uses auto-expandind Hash Treestructure, so it never needs resizing.
It also occupies less space, since empty hash slots do not consume any space.
On the other hand, the tree structure requires more seeks and is slower on access.
Its performance degrades with size, but the maximal dir node size is 128,
so degradation is very small.
TODO performance degradation depending on size. Probably  log N.</p>
<p>To achieve parallel scalability, HTreeMap is split into 16  segments,
each with a separate read-write lock. <code class="docutils literal"><span class="pre">ConcurrentHashMap</span></code> in JDK 7 works in a similar
way. The number of segments (also called concurrency scale) is hard wired
into design and cannot be changed.
Because all segments share an underlying storage, concurrent scalability is not perfect.
Another option is to create each segment with separate storage.</p>
<p>HTreeMap optionally supports entry expiration based on four criteria:
maximal map size, time-to-live since last modification and time-to-live
since last access. Expired entries are automatically removed. This
feature uses FIFO queue and each segment has independent expiration queue.
Priority per entry cannot be set.</p>
<div class="section" id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h2>
<p>HTreeMap has a number of parameters to tune its performance. The number of
segments (aka concurrency factor) is hard-coded to 16 and cannot be
changed. Other params can be set only when the map is created and cannot be
changed latter.</p>
<p>The most important are <strong>serializers</strong>. General serialization has
some guessing and overhead, so it always has better performance if
more specific serializers are used. To specify a key and value serializer, use the code
bellow. There are dozens ready to use serializers available as static
fields on <code class="docutils literal"><span class="pre">Serializer</span></code> interface:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">HTreeMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;map&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">keySerializer</span><span class="o">(</span><span class="n">Serializer</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span>
        <span class="o">.</span><span class="na">valueSerializer</span><span class="o">(</span><span class="n">Serializer</span><span class="o">.</span><span class="na">LONG</span><span class="o">)</span>
        <span class="o">.</span><span class="na">makeOrGet</span><span class="o">();</span>
</pre></div>
</div>
<p>HTreeMap is recommended for handling large key/values. In same cases you
may want to use compression. Enabling compression store-wide is not
always the best option, since a constantly (de)compressing index tree has overhead.
Instead, it is better to apply compression just to a specific serializer on key or value.
This is done by using serializer wrapper:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">HTreeMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;map&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">valueSerializer</span><span class="o">(</span><span class="k">new</span> <span class="n">Serializer</span><span class="o">.</span><span class="na">CompressionWrapper</span><span class="o">(</span><span class="n">Serializer</span><span class="o">.</span><span class="na">STRING</span><span class="o">))</span>
        <span class="o">.</span><span class="na">makeOrGet</span><span class="o">();</span>
</pre></div>
</div>
<p>Most hash maps uses 32bit hash generated by <code class="docutils literal"><span class="pre">Object.hashCode()</span></code> and check equality with <code class="docutils literal"><span class="pre">Object.equals(other)</span></code>.
However many classes do not implement those functions correctly, and inconsistent hashing is
very bad for persistence, as it could cause data loss.
By default, configuration HTreeMap uses a generic key serializer and relies on those methods as well.
However, it throws an <code class="docutils literal"><span class="pre">IllegalArgumentException</span></code> if inconsistent hashing is detected (for example <code class="docutils literal"><span class="pre">byte[]</span></code>
is used without serializer).</p>
<p>If the specialized Key Serializer is defined, HTreeMap relies on it to provide hash code and equality check
for keys. For example <code class="docutils literal"><span class="pre">Serializer.BYTE_ARRAY</span></code> uses  <code class="docutils literal"><span class="pre">java.util.Arrays.hashCode(byte[])</span></code> to generate hash code.
This way you can use primitive arrays directly as a key/value without a wrapper.
Bypassing wrappers such as <code class="docutils literal"><span class="pre">String</span></code>, improves performance:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">HTreeMap</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[],</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;map&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">keySerializer</span><span class="o">(</span><span class="n">Serializer</span><span class="o">.</span><span class="na">BYTE_ARRAY</span><span class="o">)</span>
        <span class="o">.</span><span class="na">makeOrGet</span><span class="o">();</span>
</pre></div>
</div>
<p>Another parameter is the <strong>size counter</strong>. By default HTreeMap does not keep
track of its size and calling <code class="docutils literal"><span class="pre">map.size()</span></code> requires a linear scan to count
all entries. You can enable size counter and in that case
<code class="docutils literal"><span class="pre">map.size()</span></code> is instant, but there is some overhead on inserts.</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">HTreeMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;map&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">counterEnable</span><span class="o">()</span>
        <span class="o">.</span><span class="na">makeOrGet</span><span class="o">();</span>
</pre></div>
</div>
<p>And finally some sugar. There is <strong>value creator</strong>, a function to create
a value if the existing value is not found. A newly created value is inserted
into the map. This way <code class="docutils literal"><span class="pre">map.get(key)</span></code> never returns null. This is mainly
useful for various generators and caches.</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">HTreeMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;map&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">valueCreator</span><span class="o">(</span><span class="k">new</span> <span class="n">Fun</span><span class="o">.</span><span class="na">Function1</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">Long</span> <span class="nf">run</span><span class="o">(</span><span class="n">String</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">1111L</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">})</span>
        <span class="o">.</span><span class="na">makeOrGet</span><span class="o">();</span>
</pre></div>
</div>
<p>Or a more readable version in Java 8:</p>
<div class="code java highlight-python"><div class="highlight"><pre>HTreeMap&lt;String,Long&gt; map = db.hashMapCreate(&quot;map&quot;)
        .valueCreator((key)-&gt; 1111L)
        .makeOrGet();

// this way map.get() returns 1111L if no value is found
map.get(&quot;aa&quot;); // 1111L
map.get(&quot;bb&quot;); // 1111L

// map now contains [&quot;aa&quot;-&gt;1111L, &quot;bb&quot;-&gt;1111L]
</pre></div>
</div>
</div>
<div class="section" id="entry-expiration-parameters">
<h2>Entry expiration parameters<a class="headerlink" href="#entry-expiration-parameters" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">HTreeMap</span></code> offers optional entry expiration if some conditions are
met. Entry can expire if:</p>
<ul class="simple">
<li>The number of entries in a map would exceed the maximal size</li>
<li>An entry exists in the map longer time than the expiration period is. The
expiration period could be since the last modification or since the last read
access.</li>
<li>Disk/memory space consumed by Map is bigger then some limit in GB.</li>
</ul>
<p>There is a shortcut in <code class="docutils literal"><span class="pre">DBMaker</span></code> to quickly use <code class="docutils literal"><span class="pre">HTreeMap</span></code> as an off-heap
cache with memory size limit:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="c1">// Off-heap map with max size 16GB</span>
<span class="n">Map</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">newCacheDirect</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>
</pre></div>
</div>
<p>This equals to <code class="docutils literal"><span class="pre">expireStoreSize</span></code> param:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">HTreeMap</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;cache&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">expireStoreSize</span><span class="o">(</span><span class="mi">128</span><span class="o">)</span>
        <span class="o">.</span><span class="na">makeOrGet</span><span class="o">();</span>
</pre></div>
</div>
<p>It is also possible to limit the maximal size of a map:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">HTreeMap</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;cache&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">expireMaxSize</span><span class="o">(</span><span class="mi">128</span><span class="o">)</span>
        <span class="o">.</span><span class="na">makeOrGet</span><span class="o">();</span>
</pre></div>
</div>
<p>And finally you can set an expiration time since the last modification or since
the last access.</p>
<div class="highlight-java"><div class="highlight"><pre><span class="c1">// remove entries 1 after their last modification,</span>
<span class="c1">// or 10 minutes after last get()</span>
<span class="n">HTreeMap</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;cache&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">expireAfterWrite</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">HOURS</span><span class="o">)</span>
        <span class="o">.</span><span class="na">expireAfterAccess</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MINUTES</span><span class="o">)</span>
        <span class="o">.</span><span class="na">makeOrGet</span><span class="o">();</span>
</pre></div>
</div>
<p>TODO expiration counts are approximate. Map size can go slightly over limits for short period of time.</p>
<p>TODO disk space limit has issues. Investigate how it works and document</p>
<p>TODO expiration threads single and multithreaded.</p>
</div>
<div class="section" id="binding-and-overflow">
<h2>Binding and overflow<a class="headerlink" href="#binding-and-overflow" title="Permalink to this headline">¶</a></h2>
<p>Maps in MapDB support call back notification on insert, update and removal.
There is <code class="docutils literal"><span class="pre">Bind</span></code> class (TODO link to chapter), which links two collections together and keeps them synchronized.
There are several ways to associate collections but this is described in a separate chapter (TODO link).</p>
<p>Specific for <code class="docutils literal"><span class="pre">HTreeMap</span></code> is the expiration overflow. It is possible tokeep the most recently used
entries in memory for faster access. After the entry expires, it is moved to a slower storage on disk.</p>
<p>To create overflow you need two maps. One on-disk and one in-memory. You bind them together with the
<code class="docutils literal"><span class="pre">.expireOverflow(onDisk,</span> <span class="pre">true)</span></code> parameter in builder:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">DB</span> <span class="n">dbDisk</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">fileDB</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>

<span class="n">DB</span> <span class="n">dbMemory</span> <span class="o">=</span> <span class="n">DBMaker</span>
        <span class="o">.</span><span class="na">memoryDB</span><span class="o">()</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>

<span class="c1">// Big map populated with data expired from cache</span>
<span class="n">HTreeMap</span> <span class="n">onDisk</span> <span class="o">=</span> <span class="n">dbDisk</span>
        <span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;onDisk&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>

<span class="c1">// fast in-memory collection with limited size</span>
<span class="n">HTreeMap</span> <span class="n">inMemory</span> <span class="o">=</span> <span class="n">dbMemory</span>
        <span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;inMemory&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">expireAfterAccess</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">)</span>
        <span class="c1">//this registers overflow to `onDisk`</span>
        <span class="o">.</span><span class="na">expireOverflow</span><span class="o">(</span><span class="n">onDisk</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
        <span class="c1">//good idea is to enable background expiration</span>
        <span class="o">.</span><span class="na">executorEnable</span><span class="o">()</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
<p>Once binding is established, every entry removed from <code class="docutils literal"><span class="pre">inMemory</span></code> map will be added to <code class="docutils literal"><span class="pre">onDisk</span></code> map.
This applies to expired entries, but also entries removed using the <code class="docutils literal"><span class="pre">map.remove()</span></code> method.
To completely remove entry from both maps, one must first remove from <code class="docutils literal"><span class="pre">inMemory</span></code> and then from <code class="docutils literal"><span class="pre">onDisk</span></code>:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="c1">//first remove from inMemory</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
<span class="c1">//key will be moved to onDisk after deletion by modification listener, remove from onDisk</span>
<span class="n">onDisk</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">);</span>
</pre></div>
</div>
<p>If the <code class="docutils literal"><span class="pre">inMemory.get(key)</span></code> is called, one might expect null, and than check <code class="docutils literal"><span class="pre">onDisk</span></code>. However to make things simpler
<code class="docutils literal"><span class="pre">inMemory</span></code> has a value creator. So <code class="docutils literal"><span class="pre">inMemory.get(key)</span></code> returns values from both <code class="docutils literal"><span class="pre">inMemory</span></code> and <code class="docutils literal"><span class="pre">onDisk</span></code>.
If value is not found, it checks the second map and adds its value into <code class="docutils literal"><span class="pre">inMemory</span></code>.</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">onDisk</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="s">&quot;one&quot;</span><span class="o">);</span>    <span class="c1">//onDisk has content, inMemory is empty</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>        <span class="c1">//&gt; 0</span>
<span class="c1">// get method will not find value inMemory, and will get value from onDisk</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>        <span class="c1">//&gt; &quot;one&quot;</span>
<span class="c1">// inMemory now caches result, it will latter expire and move to onDisk</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>        <span class="c1">//&gt; 1</span>
</pre></div>
</div>
<p>Get and removal synchronizes two collections in a cyclic way. The entry gets moved into <code class="docutils literal"><span class="pre">onDisk</span></code> when its deleted from <code class="docutils literal"><span class="pre">inMemory</span></code>.
And <code class="docutils literal"><span class="pre">inMemory</span></code> gets populated from <code class="docutils literal"><span class="pre">onDisk</span></code> when get method does not find a value in-memory. This creates a consistency problem,
as to which map is authoritative? Which contains the &#8216;real&#8217; data?</p>
<p>MapDB offers three alternatives. The method <code class="docutils literal"><span class="pre">.expireOverflow(onDisk,</span> <span class="pre">true)</span></code> takes a boolean parameter to control
how expiration behaves. With <code class="docutils literal"><span class="pre">false</span></code> expiration it uses <code class="docutils literal"><span class="pre">map.put(key,value)</span></code> to insert data to inDisk.
With <code class="docutils literal"><span class="pre">true</span></code> it uses <code class="docutils literal"><span class="pre">map.putIfAbsent(key,value</span></code>, so no existing value gets overwritten.</p>
<p>The first option is <code class="docutils literal"><span class="pre">true</span></code>. It means that <code class="docutils literal"><span class="pre">inMemory</span></code> is authoritative and <code class="docutils literal"><span class="pre">onDisk</span></code> content will get
overwritten once the data expires from memory and overflows to disk:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">HTreeMap</span> <span class="n">inMemory</span> <span class="o">=</span> <span class="n">dbMemory</span>
        <span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;inMemory&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">expireOverflow</span><span class="o">(</span><span class="n">onDisk</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span> <span class="c1">// &lt;&lt;&lt; true here</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>

<span class="c1">//add two different entries</span>
<span class="n">onDisk</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;uno&quot;</span><span class="o">);</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">);</span>
<span class="c1">//simulate expiration by removing entry</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="c1">//data onDisk are overwritten, inMemory wins</span>
<span class="n">onDisk</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>      <span class="c1">//&gt; &quot;one&quot;</span>
<span class="c1">// inMemory gets repopulated from onDisk</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>    <span class="c1">//&gt; &quot;one&quot;</span>
</pre></div>
</div>
<p>With <code class="docutils literal"><span class="pre">false</span></code>, the data added into <code class="docutils literal"><span class="pre">inMemory</span></code> are not considered authoritative. OnDisk content will never get
overwritten. This also adds a performance bonus on expiration if the values are the same, since on-disk values
are not overwritten by equal values.</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">HTreeMap</span> <span class="n">inMemory</span> <span class="o">=</span> <span class="n">dbMemory</span>
        <span class="o">.</span><span class="na">hashMapCreate</span><span class="o">(</span><span class="s">&quot;inMemory&quot;</span><span class="o">)</span>
        <span class="o">.</span><span class="na">expireOverflow</span><span class="o">(</span><span class="n">onDisk</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span> <span class="c1">// &lt;&lt;&lt; false here</span>
        <span class="o">.</span><span class="na">make</span><span class="o">();</span>

<span class="c1">//add two different entries</span>
<span class="n">onDisk</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;uno&quot;</span><span class="o">);</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">);</span>
<span class="c1">//simulate expiration by removing entry</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="c1">//data onDisk are not overwritten, inMemory loses</span>
<span class="n">onDisk</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>      <span class="c1">//&gt; &quot;uno&quot;</span>
<span class="c1">// inMemory gets repopulated from onDisk</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>    <span class="c1">//&gt; &quot;uno&quot;</span>

<span class="c1">//add stuff to inMemory and expire it</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="s">&quot;two&quot;</span><span class="o">);</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
<span class="c1">//onDisk still gets updated, because it did not contained this key</span>
<span class="n">onDisk</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">//&gt; two</span>
</pre></div>
</div>
<p>There is a question into which collection new data should be inserted. It depends how much you value your data.
If it caches some external source (such as SQL), I would insert data into <code class="docutils literal"><span class="pre">inMemory</span></code> and let them hoover in air.
In this case data might be inconsistent after crash/shutdown. It is better to drop the cache content and
repopulate it from the primary store.</p>
<p>If thee content of the cache is valuable (is primary content, or too high cost to repopulate from SQL)
one should insert data to <code class="docutils literal"><span class="pre">onDisk</span></code>.
Disk store can be protected by transaction with periodic commit.
In this case only a small time interval of data would be lost.</p>
<p>Inserts are simple, but updates create a consistency problem. If the key-value pair changes, one collection might contain
an older value. So on updates it is recommended to update BOTH <code class="docutils literal"><span class="pre">inMemory</span></code> and <code class="docutils literal"><span class="pre">onDisk</span></code> collections:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="c1">//put value to on disk</span>
<span class="n">onDisk</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">);</span>
<span class="c1">//in memory gets updated from on disk, no problem here</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//&gt; &quot;one&quot;</span>

<span class="c1">//updating just one collection creates consistency problem</span>
<span class="n">onDisk</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="s">&quot;uno&quot;</span><span class="o">);</span>
<span class="c1">//old content of inMemory has not expired yet</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//&gt; &quot;one&quot;</span>

<span class="c1">//one has to update both collections at the same time</span>
<span class="n">onDisk</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="s">&quot;uno&quot;</span><span class="o">);</span>
<span class="n">inMemory</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="s">&quot;uno&quot;</span><span class="o">);</span>
</pre></div>
</div>
<p>The third option is to use listeners and <code class="docutils literal"><span class="pre">Bind</span></code> utilities yourself.</p>
</div>
<div class="section" id="concurrent-scalability">
<h2>Concurrent scalability<a class="headerlink" href="#concurrent-scalability" title="Permalink to this headline">¶</a></h2>
<p>HTreeMap scales concurrently by using 16 separate segments, each with its own <code class="docutils literal"><span class="pre">ReadWriteLock</span></code>.
Each segment has its own independent state, hash tree and also expiration queue.
But all segments still share underlying storage and are limited by its performance.</p>
<p>There is an option to shard HTreeMap. Each separate segment can get its own storage, so no shared
state exist between segments. This way one can get linear concurrent scalability which corresponds
to 16 segments. TODO benchmarks.</p>
<p>Trade off in this case is a higher memory consumption. There are 16 different stores, each with its own
memory allocator and unused blocks. TODO memory benchmarks.
But each store can be compacted separately. TODO add compaction doc for this</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">DBMaker</span>
       <span class="o">.</span><span class="na">hashMapSegmentedMemory</span><span class="o">()</span>
       <span class="o">.</span><span class="na">keySerializer</span><span class="o">(</span><span class="n">Serializer</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span>
       <span class="o">.</span><span class="na">valueSerializer</span><span class="o">(</span><span class="n">Serializer</span><span class="o">.</span><span class="na">BYTE_ARRAY</span><span class="o">)</span>
       <span class="o">.</span><span class="na">make</span><span class="o">();</span>
</pre></div>
</div>
</div>
<div class="section" id="compared-to-btreemap">
<h2>Compared to BTreeMap<a class="headerlink" href="#compared-to-btreemap" title="Permalink to this headline">¶</a></h2>
<p><cite>HTreeMap</cite> has a major advantage over <cite>BTreeMap</cite> with large keys. Unlike
BTreeMap, it only stores hash codes in tree nodes.
BTreeMap deserializes tree nodes, together with their keys, on each lookup.
A simple <code class="docutils literal"><span class="pre">BTreeMap.get(key)</span></code> could deserialize houndreds of keys.</p>
<p>TODO link to performance test, compare with BTreeMap</p>
<p>On the other side HTreeMap has a limited concurrency factor to 16, so with
writes it wont scale over 4 CPU cores. It uses read-write locks, so read
operations are not affected. However, in practice the disk IO is more likely
to be bottleneck. TODO benchmarks</p>
<p>HTreeMap can be easily sharded by segments. For in-memory map it might have better
concurrent scalability.</p>
<p>HTreeMap is simpler than BTreeMap. It has more predictable performance over a long period of time
and it does not get fragmented after frequent deletes.
HTreeMap also offers expiration.
BTreeMap pays tax in some cases for its complex lock-free design.</p>
</div>
</div>

  <div class="section">
  
  
  </div>


                <script>

if(window.location.href.indexOf('/blog/')>-1){

document.write('<br><br><br><hr><br><div id="disqus_thread"></div>');


/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = 'http://www.mapdb.org'; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'mapdb'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//mapdb.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();

}
</script>

            </div>
        </div>
    </div>

    <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="secondary-collections.html" title="Secondary Collections"
             >next</a> |</li>
        <li class="right" >
          <a href="btreemap.html" title="BTreeMap"
             >previous</a> |</li>
        <li><a href="../index.html">Home</a>&nbsp;|</li>
        <li><a href="../contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >MapDB Manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Jan Kotek.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>