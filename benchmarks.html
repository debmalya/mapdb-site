<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>In-memory benchmarks &mdash; MapDB</title>
    
    <link rel="stylesheet" href="_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="MapDB" href="index.html" />
    <link rel="up" title="Contents" href="contents.html" />
    <link rel="next" title="Changelog for 2.X releases" href="changelog.html" />
    <link rel="prev" title="Contents" href="contents.html" />
  
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

<!-- google analytics-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42074659-1', 'auto');
  ga('send', 'pageview');

</script>

  
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.post-list-style-disc {list-style-type: disc;}
    ul.post-list-style-none {list-style-type: none;}
    ul.post-list-style-circle {list-style-type: circle;}
  </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    <li><a href="index.html">Home</a></li>
    <li><a href="doc/getting-started.html">Intro</a></li>
    <li><a href="doc/index.html">Docs</a></li>
    <li><a href="/blog.html">Blog</a></li>
    <li><a href="https://github.com/jankotek/mapdb">Github</a></li>
  </ul>
  <div>
    <a href="index.html">
      <img src="_static/logo.png" alt="MapDB" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="changelog.html" title="Changelog for 2.X releases"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="contents.html" title="Contents"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Home</a>&nbsp;|</li>
        <li><a href="contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="contents.html" accesskey="U">Contents</a> &raquo;</li> 
      </ul>
    </div>
    <div class="document">
    <div class="documentwrapper">
        <div class="bodywrapper">
            <div class="body" role="main">
                
  <div class="section" id="in-memory-benchmarks">
<h1>In-memory benchmarks<a class="headerlink" href="#in-memory-benchmarks" title="Permalink to this headline">¶</a></h1>
<p>MapDB provides more advanced alternative to Java Collections.
This benchmarks compares various <cite>Map</cite> implementations.
Its purpose is to show MapDB as reasonable alternative to Java Collections for some cases.</p>
<p>MapDB supports many features, uses less space and does serialization.
Despite that it has performance comparable to Java Collections; sometimes it is faster,
sometimes it is &#8220;only&#8221; 10 times slower. Also current MapDB 2.0 release is not fastest,
it is initial naive implementation, we plan performance optimisations in 2.1 release.</p>
<p>This benchmarks tries to be objective.
It is used for performance regression testing and MapDB development depends on its precision.
Java Collections suffer greatly from Garbage Collection overhead, we made sure this is not a case here.
MapDB maps scale to terabytes without a hiccup.
It would be easy to show MapDB as much faster, by increasing Map size.</p>
<p>Benchmark source is in <a class="reference external" href="https://github.com/jankotek/mapdb-benchmarks">Github repo</a>.
Please send Pull Request if you have improvements.
All tests ran on 64bit JDK8.</p>
<div class="section" id="maps">
<h2>Maps<a class="headerlink" href="#maps" title="Permalink to this headline">¶</a></h2>
<p>There are six maps in test. All tests work on Map with 100 million entries, <code class="docutils literal"><span class="pre">Long</span></code> key and <code class="docutils literal"><span class="pre">UUID</span></code> value.</p>
<p><code class="docutils literal"><span class="pre">ConcurrentHashMap</span></code> is regular concurrent <code class="docutils literal"><span class="pre">HashMap</span></code> bundled with Java.</p>
<p><code class="docutils literal"><span class="pre">ConcurrentSkipListMap</span></code> is concurrent version of <code class="docutils literal"><span class="pre">java.util.TreeMap</span></code> bundled with Java.</p>
<p><code class="docutils literal"><span class="pre">HTreeMap</span></code> is concurrent <code class="docutils literal"><span class="pre">HashMap</span></code> implementation from MapDB. It is optimized for bigger keys and large number of entries.
It has some nice features such as entry expiration with TTL or maximal size.</p>
<p><code class="docutils literal"><span class="pre">BTreeMap</span></code> is concurrent <code class="docutils literal"><span class="pre">TreeMap</span></code> implementation from MapDB. It is optimized for minimal space usage and for small keys.
It has specialized keys (for example <code class="docutils literal"><span class="pre">Long</span></code> key is stored as primitive <code class="docutils literal"><span class="pre">long</span></code>) and other nice features.</p>
<p>MapDB works in two modes. <code class="docutils literal"><span class="pre">heap</span></code> mode does not use serialization. Everything is stored on heap, as object instances.
Heap mode is affected by Garbage Collector. This mode is usually faster for smaller sets.</p>
<p><code class="docutils literal"><span class="pre">offheap</span></code> mode serializes all data into in-memory binary store. It is not affected by Garbage Collector.
It is better for large maps, it runs just fine with 500GB store size.</p>
</div>
<div class="section" id="memory-usage">
<h2>Memory usage<a class="headerlink" href="#memory-usage" title="Permalink to this headline">¶</a></h2>
<p>This graph show how much entries Map can fit into 1GB of heap memory.
JVM starts with 1GB maximal heap size (<cite>-Xmx1G</cite>).
Entries are added into <cite>Map&lt;Long,UUID&gt;</cite> until JVM terminates with <cite>OutOfMemoryException</cite>.
Key is 8-byte`java.util.Long` number, value is 16-byte <cite>java.util.UUID</cite> number
Small objects were chosen to better illustrate space overhead of internal Map structures (nodes, hash table..)</p>
<p class="centered">
<strong><strong>Number of entries inserted into Map with 1GB heap, before JVM runs out of memory (higher is better)</strong></strong></p><img alt="_images/InMemorySpaceUsage.png" src="_images/InMemorySpaceUsage.png" />
<p>Offheap BTreeMap has very impressive result thanks to Key Delta Compression. It serializes key array by only storing
differences between neighbour keys. There is no trick here, just lot of optimizations.
Delta Compression have almost zero overhead and Map is modifiable with reasonable performance.
Also similar technique is here for Strings, Arrays...
We could save another 20% of space by using read-only Archive storage.</p>
<p class="centered">
<strong><strong>The same graph, but without BTreeMap_offheap</strong></strong></p><img alt="_images/InMemorySpaceUsage2.png" src="_images/InMemorySpaceUsage2.png" />
<p>This chart has BTreeMap_offheap removed to better illustrate difference between remaining five collections.</p>
<p><code class="docutils literal"><span class="pre">HTreeMap_heap</span></code> is not so good thanks to its expandable hash table. In decompressed heap form it takes lot of space.
But in compacted form <code class="docutils literal"><span class="pre">HTreeMap_offheap</span></code> take a lot less space.</p>
<p><code class="docutils literal"><span class="pre">BTreeMap_heap</span></code> is bit more space efficient compared to Java Collections.
It stores keys in primitive form (<code class="docutils literal"><span class="pre">long</span></code> versus <code class="docutils literal"><span class="pre">Long</span></code>) and that requires less pointers.</p>
</div>
<div class="section" id="random-updates">
<h2>Random updates<a class="headerlink" href="#random-updates" title="Permalink to this headline">¶</a></h2>
<p class="centered">
<strong><strong>Time to update 100M random keys on Map with 100M entries (smaller is better)</strong></strong></p><img alt="_images/InMemoryUpdate.png" src="_images/InMemoryUpdate.png" />
<p><code class="docutils literal"><span class="pre">ConcurrentHashMap</span></code> in this case rocks.</p>
<p><code class="docutils literal"><span class="pre">BTreeMap_heap</span></code> takes advantage of its specialized keys. Binary search in primitive form is more efficient
and there is no surprise it outperforms <code class="docutils literal"><span class="pre">ConcurrentSkipListMap</span></code>.</p>
<p>Another surprise is reasonable performance of both offheap collections.
They are doing (de)serialization on top of everything and it shows how optimized MapDB code is.</p>
</div>
<div class="section" id="random-gets">
<h2>Random gets<a class="headerlink" href="#random-gets" title="Permalink to this headline">¶</a></h2>
<p class="centered">
<strong><strong>Time to get 100M random keys on Map with 100M entries (smaller is better)</strong></strong></p><img alt="_images/InMemoryGet.png" src="_images/InMemoryGet.png" />
<p><code class="docutils literal"><span class="pre">ConcurrentHashMap</span></code> rocks again.</p>
<p><code class="docutils literal"><span class="pre">ConcurrentSkipListMap</span></code> seems bit slower compared to MapDB heap collections. SkipList is not CPU cache friendly.</p>
<p>Another surprise is reasonable performance of both offheap collections.
They are doing deserialization on top of everything and it shows how optimized MapDB code is.</p>
</div>
</div>

  <div class="section">
  
  
  </div>


                <script>

if(window.location.href.indexOf('/blog/')>-1){

print('<br><br><br><hr><br><div id="disqus_thread"></div>');


/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = 'http://www.mapdb.org'; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'mapdb'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//mapdb.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();

}
</script>

            </div>
        </div>
    </div>

    <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="changelog.html" title="Changelog for 2.X releases"
             >next</a> |</li>
        <li class="right" >
          <a href="contents.html" title="Contents"
             >previous</a> |</li>
        <li><a href="index.html">Home</a>&nbsp;|</li>
        <li><a href="contents.html">Documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="contents.html" >Contents</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Jan Kotek.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>